<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Answers</title>
</head>
<body>
	<div class="faq">
		<div class="pair">
			<p class="question">1.Что такое EcmaScript?</p>
			<p class="answer">
				EcmaScript содержит правила, сведения и рекомендации, которые должны соблюдаться скриптовым языком, чтобы он считался совместимым с EcmaScript. EcmaScript - это стандарт языка JavaScript. То есть это спецификация на которой основан JavaScript. А уже из документации JavaScript можно узнать как использовать скриптовый язык.
			</p>
		</div>
		<div class="pair">
			<p class="question">2.Для чего используются и чем отличаются атрибуты async и defer?</p>
			<p class="answer">
				async и defer - это атрибуты тега script, для которых не указываются значения. Оба они используются для примитивной регулировки загрузки скриптов, но существуют и более продвинутые. async - загружает скрипт параллельно с загрузкой остального контента. Скрипт выполнится как только будет загружен. defer - выполняет скрипт только после полной загрузки страницы, и сохраняет очередность выполнения.
			</p>
		</div>
		<div class="pair">
			<p class="question">3.Почему предпочтительнее подключать скрипты перед &lt;/body&gt;, а не в &lt;head&gt;...&lt;/head&gt;?</p>
			<p class="answer">
				Предпочтительнее подключать скрипты перед &lt;/body&gt;, так как скрипты начнут грузится после загрузки основного контента. Если же подключить скрипт в &lt;head&gt;...&lt;/head&gt;, то сначала будут грузиться все скрипты и только потом остальной контент. В &lt;head&gt;...&lt;/head&gt; подключается тот скрипт, который важен для работы всех скриптов, а перед &lt;/body&gt; - для быстрой загрузки страницы в браузере. Очередность подключения тоже важна.
			</p>
		</div>
		<div class="pair">
			<p class="question">4.Какие основные отличия интерпретируемого языка программирования от компилируемого?</p>
			<p class="answer">
				Для использования компилируемых языков (C, C++, Go, Haskell, Rust) необходим компилятор, который переведет программу в понятный для машины код и только после этого код будет исполнен в операционной системе. Поскольку они конвертируются в машинный код, они работают гораздо быстрее и эффективнее, чем интерпретируемые. Но недостатком является то, что для тестирования любого изменения программу нужно заново компилировать, и такие языки платформо-зависимые (поскольку машинный код зависит от машины, на которой компилируется и исполняется программа). Интерпретируемые (JavaScript, PHP, Perl, Ruby, Python) же языки не нуждаются в переводе, нужна только программа-интерпретатор, которая исполнит код построчно вместо операционной системы. Плюсы их использования: независимость от платформы, рефлексия, динамическая типизация, меньший размер исполняемых файлов, динамические области видимости. Основным недостатком интерпретируемых языков является их невысокая скорость исполнения. Многие языки программирования имеют как компилируемую, так и интерпретируемую версии.
			</p>
		</div>
		<div class="pair">
			<p class="question">5.Что такое языки высокого и низкого уровня? Какие ты знаешь?</p>
			<p class="answer">
				Языки программирования низкого уровня - это те, которые имеют прямой доступ к памяти и регистрам, и позволяют задавать машинные команды в понятном для человека виде. Для преобразования их в двоичный код были созданы специальные программы — трансляторы (компиляторы и интерпретаторы). Языки низкого уровня ориентированы на конкретный тип процессора и учитывают его особенности, поэтому для переноса программы на другую аппаратную платформу её нужно почти полностью переписать. Определенные различия есть и в синтаксисе программ под разные компиляторы. Примерами таких языков программирования являются: Ассемблер, CIL, Forth. Высокоуровневый язык программирования — язык программирования, разработанный для быстроты и удобства использования программистом. Особенности конкретных компьютерных архитектур в них не учитываются, поэтому созданные приложения легко переносятся с компьютера на компьютер. В большинстве случаев достаточно просто перекомпилировать программу под определенную компьютерную архитектурную и операционную систему. Примерами таких языков программирования являются: C++, C#, Visual Basic, Python, Perl, Fortran, Delphi и др..
			</p>
		</div>
		<div class="pair">
			<p class="question">6.Для чего используются переменные? Какие ключевые слова используются для создания переменных? Какие есть отличия в переопределении значений при задании переменной через let, const и var?</p>
			<p class="answer">
				Переменные используются для записи значения, чтобы в дальнейшем его использовать. Ключевыми словами для создания переменных являются var, let и const. var - устаревший способ, так как переменную, заданную им, легко можно переопределить (изменить значение) и может возникнуть путаница. Переменную заданную с помощью const нельзя переопределить. А переменную заданную через let нельзя прямо переопределить (для этого нужно записать название и значение переменной без ключевого слова).
			</p>
		</div>
		<div class="pair">
			<p class="question">7.Может ли имя переменной начинаться с цифры, символов _ или $?</p>
			<p class="answer">
				Имя переменной не может начинаться с цифры (цифры могут входить в его состав). Но может начинаться и состоять из символов _ или $ (другие символы использовать неправильно).
			</p>
		</div>
		<div class="pair">
			<p class="question">8.Какие слова запрещено использовать в названии переменной?</p>
			<p class="answer">
				В названии переменной запрещено использовать слова, которые используются самим языком программирования. Например, const, let, class, return, export и другие. Существует целый список таких зарезервированных слов. В названии переменных можно использовать и русские буквы, но это не рекомендуется. Также не используется транслит!
			</p>
		</div>
		<div class="pair">
			<p class="question">9.Что такое camelCase и snake_case?</p>
			<p class="answer">
				Переменные, состоящие из нескольких слов, пишутся с использованием записи camelCase или snake_case. При использовании записи camelCase несколько слов пишутся слитно без пробелов, при этом каждое слово внутри фразы пишется с прописной буквы (например, borderLeftWidth). Существует альтернативный стандарт, когда несколько слов пишутся через знак подчеркивания '_' - это так называемый snake_case. Преимущественно в JavaScript используется camelCase.
			</p>
		</div>
		<div class="pair">
			<p class="question">10.Что такое "типы данных"? Какой оператор позволяет определить тип данных?</p>
			<p class="answer">
				В программировании тип данных это множество допустимых значений, которые могут принимать данные, принадлежащие к этому типу. Чтобы иметь возможность работать с переменной, важно знать ее тип. В JavaScript существует несколько основных типов данных. Они делятся на примитивные (числа (numbers), строки (strings), логические (boolean), символ (symbol), null, udefined) и сложные (объекты (objects), массивы (arrays), функции (functions)). typeof - оператор, позволяющий определить тип данных.
			</p>
		</div>
		<div class="pair">
			<p class="question">11.Что такое "динамическое приведение типов данных"? Можно ли писать JavaScript со статическим приведением типов?</p>
			<p class="answer">
				Динамическое приведение типов данных - это процесс преобразования значений переменной из одного типа в другой, при этом определение типа переменной происходит не во время ее объявления, а когда ей присвается конкретное значение при запуске. JavaScript - язык с динамической типизацией. Но писать JavaScript со статическим приведением типов можно. Для этого используются инструменты вроде Flow и TypeScript. Flow — это open source библиотека для статической проверки типов, которую разработала и выпустила Facebook. Она позволяет постепенно добавлять типы в код JavaScript. TypeScript - новый язык программирования со статической типизацией (указание типа переменной при её объявлении). TypeScript представляет собой надмножество, которое компилируется в JavaScript (то есть, любой код на JS является правильным с точки зрения TypeScript). Но перед его использованием нужно очень хорошо изучить полную систему типов и как наилучшим образом их выбирать в программе. Также из-за статических типов программы часто выглядят более многословными и загроможденными, соответственно на их написание тратится больше времени. Плюсами является: возможность писать меньше тестов — все параметры методов жестко описаны, и если код скомпилировался, тогда, вероятно, каждый вызов является валидным, и не требует дополнительной проверки; скорость выполнения; при некоторых дополнительных условиях, позволяет обнаруживать потенциальные ошибки уже на этапе компиляции.
			</p>
		</div>
		<div class="pair">
			<p class="question">12.Как привести строчное значение "10" к числу? Назовите два способа.</p>
			<p class="answer">
				Для преобразования строчного значения "10" к числу в явном виде можно вызвать Number('10'), либо, что короче, поставить перед выражением унарный плюс '+': +'10'.
			</p>
		</div>
		<div class="pair">
			<p class="question">13.Чем отличаются операторы "==" и "==="?</p>
			<p class="answer"
			>== это оператор не строгого сравнения, а === оператор строгого. Оператор строгого сравнения учитывает не только значение переменной, но и тип данных (то есть, если значение совпадает, а тип данных нет, то будет считаться, что равенства нет).
		</p>
		</div>
		<div class="pair">
			<p class="question">14.Какие преимущества дают обратные кавычки (`) при указании строки?</p>
			<p class="answer">
				Обратные кавычки дают возможность использовать интерполяцию. Интерполяция позволяет использовать переменные или выражения в строке и легко переносить строку.
			</p>
		</div>
		<div class="pair">
			<p class="question">15.Что такое "алгоритм"? Какие ты знаешь типы алгоритмов?</p>
			<p class="answer">
				Алгоритм – это набор инструкций, описывающих порядок действий исполнителя для достижения некоторого результата. Существуют такие типы алгоритмов: линейный (состоит из команд, выполняемых последовательно во времени друг за другом), разветвленный (условный - содержит хотя бы одно условие, в результате которого может осуществляться разделение на несколько альтернативных ветвей алгоритма), циклический (предусматривает многократное повторение одного и того же действия над новыми исходными данными).
			</p>
		</div>
		<div class="pair">
			<p class="question">16.Зачем нужны циклы? Какие виды циклов ты знаешь? В чем их основные отличия?</p>
			<p class="answer">
				Циклы используются для многократного повторения одного участка кода (выполнения повторяющихся вычислений). Они оптимизируют процесс написания кода. Существуют такие виды циклов: while, do…while (редко используются, т.к. считается, что они сложнее воспринимаются визуально), for (используются чаще всего), for…in, бесконечный цикл и вложенный цикл. Цикл while проверяет условие, и если оно приравнивается к true, то тело цикла выполняется. Цикл do…while сначала выполняет тело, а уже потом проверяет соответствие условию. Цикл for проверяет условие перед каждой итерацией, пока не произойдет какое-либо специальное событие завершения цикла. Цикл for…in проходит через перечисляемы свойства объекта. Он пройдет по каждому отдельному элементу.
			</p>
		</div>
		<div class="pair">
			<p class="question">17.Что делают операторы ++i и i++ и в чем их отличие?</p>
			<p class="answer">
				Операторы ++i и i++ (более короткая запись для i = i + 1) – это инкремент, который используется для увеличения числа на 1. Инкремент можно применить только к переменной и использовать для любых выражений! ++i – его префиксная форма, а i++ - постфиксная. Отличаются они тем, что постфиксная форма возвращает старое значение (до увеличения на 1), а префиксная форма сразу возвращает увеличенное значение. Если результат оператора не используется, а нужно только увеличить переменную – без разницы, какую форму использовать. Эта разница видна только если результат оператора сразу используется. Тоже самое для декремента (--i, i--), который используется для уменьшения числа на 1.
			</p>
		</div>
		<div class="pair">
			<p class="question">18.Что такое "итерация"?</p>
			<p class="answer">
				Итерация – это каждое повторение цикла.
			</p>
		</div>
		<div class="pair">
			<p class="question">19.Как называются и чем отличаются операторы || и &&?</p>
			<p class="answer">
				|| и && - это логические операторы, но в JavaScript могут применяться к значениям любого типа и возвращают также значения любого типа. || - оператор "ИЛИ", && - оператор "И". Оператор || вычисляет операнды слева направо до первого "истинного" (true) и возвращает его ("короткий цикл вычисления"), а если все ложные (false) – то последнее значение. Причём, не преобразованное к логическому типу. Обычно оператор || используется в if, чтобы проверить, выполняется ли хотя бы одно из условий. Оператор && вычисляет операнды слева направо до первого «ложного» (false) и возвращает его, а если все истинные (true) – то последнее значение. Как и в ИЛИ, в И допустимы любые значения. То есть к операторам || и && применяется принцип "короткого цикла вычислений", но немного отличающийся.
			</p>
		</div>
		<div class="pair">
			<p class="question">20.Для чего используется break? Почему в конструкции switch нужно использовать break для каждого case?</p>
			<p class="answer">
				Директива break используется для выхода из цикла. Если не указан break после каждого case, то выполнение цикла пойдет ниже по следующим case, при этом остальные проверки игнорируются.
			</p>
		</div>
		<div class="pair">
			<p class="question">21.Почему при выполнении указанного кода возникают ошибки?</p>
			<p class="answer">
				(1) Это бесконечный цикл. Чтобы избежать создания бесконечного цикла, нужно убедиться, что заданное условие в какой-то момент вернёт false. Заданное условие никогда не вернет false, потому что переменная i всегда будет равна 0 и соответственно меньше 10.<br>
				(2) Лишняя точка с запятой (;) перед телом цикла (перед фигурной скобкой). Пропущено ключевое слово let перед объявлением переменной.<br>
				(3) Не указан break после каждого условия, то есть цикл не будет останавливаться на правильном варианте а будет выполняться до конца, при этом остальные проверки игнорируются.<br>
				(4) Вводимое пользователем число считается строкой. Нужно чтобы переменная считывалась как числовая, а не строчная. Это можно исправить, добавив унарный "+" перед prompt.<br>
			</p>
		</div>
		<div class="pair">
			<p class="question">22.Зачем нужны функции?</p>
			<p class="answer">
				Функции нужны для повторения одного и того же кода в разных частях программы, чтобы не писать его многократно. Функция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие.
			</p>
		</div>
		<div class="pair">
			<p class="question">23.Сколько параметров можно передать функции?</p>
			<p class="answer">
				При вызове функции ей можно передать данные, которые та использует по своему усмотрению. Параметры копируются в локальные переменные функции. Параметров можно передавать больше или меньше, чем необходимо. То есть функцию можно вызвать с любым количеством параметров. Не будет никакой ошибки. Если параметр не передан при вызове – он считается равным undefined.
			</p>
		</div>
		<div class="pair">
			<p class="question">24.Что случится, если передать в функцию меньше параметров, чем нужно? А если больше? Объясни на примере функции add(a, b).</p>
			<p class="answer">
				Параметры функции – такие же переменные, но их начальные значения задаются при вызове функции, а не в её коде. Если не передать в функцию параметр a или b, то непереданные будут считаться равными undefined. А если передать в функцию add больше параметров чем 2 ошибки не произойдет. Но, чтобы получить такие «лишние» аргументы, нужно будет прочитать их из специального объекта arguments. Он содержит список аргументов по номерам: arguments[0], arguments[1]…, а также свойство length. Все параметры находятся в arguments, даже если они есть в списке. arguments – это не массив Array. В действительности, это обычный объект, просто ключи числовые и есть length. На этом сходство заканчивается. Никаких особых методов у него нет, и методы массивов он тоже не поддерживает. В старом стандарте JavaScript псевдо-массив arguments и переменные-параметры ссылаются на одни и те же значения. То есть в результате изменения arguments влияют на параметры и наоборот.В современной редакции стандарта это поведение изменено. Аргументы отделены от локальных переменных.
			</p>
		</div>
		<div class="pair">
			<p class="question">25.Возможно ли для параметра указать значение по умолчанию? Назови два способа?</p>
			<p class="answer">
				Для параметра функции можно указать значение по умолчанию. Для этого используется два способа. Первый способ: проверть с помощью оператора if равен ли аргумент undefined, и если да – то записать в него значение по умолчанию. Второй способ: использовать оператор || (запись выглядит так: text = text || 'текст не передан';). То есть считается, что аргумент отсутствует, если передана пустая строка, 0, или вообще любое значение, которое в логическом контексте является false. Также можно указывать параметры по умолчанию через "=" в списке параметров в скобках после имени функции. Параметр по умолчанию используется при отсутствующем аргументе или равном undefined. При передаче любого значения, кроме undefined, включая пустую строку, ноль или null, параметр считается переданным, и значение по умолчанию не используется. Параметры по умолчанию могут быть не только значениями, но и выражениями.
			</p>
		</div>
		<div class="pair">
			<p class="question">26.Что такое область видимости?</p>
			<p class="answer">
				Переменные объявленные внутри функции нельзя вызвать вне. То есть внутри функции создается локальная область видимости. Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных. При объявлении переменной в таких блоках, она всё равно будет видна во всей функции. Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию. Переменные, объявленные на уровне всего скрипта, называют «глобальными переменными». Функция может обратиться к таким внешним переменным. Доступ возможен не только на чтение, но и на запись. При этом, так как переменная внешняя, то изменения будут видны и снаружи функции.
			</p>
		</div>
		<div class="pair">
			<p class="question">27.Чем отличается Function Declaration от Function Expression?</p>
			<p class="answer">
				 Function Declaration от Function Expression это синтаксисы для объявления функции. Функции, созданные с помощью Function Declaration создаются интерпретатором до выполнения кода, поэтому их можно вызвать раньше объявления (такое поведение называют термином "поднятие" (hoisting)). Так же их не используют для условного объявление в if. А функции, созданные с помощью Function Expression нельзя вызвать до оглашения, потому что интерпретатор создает их, когда доходит до строчки кода в которой записана функция. И они работают в if.
			</p>
		</div>
		<div class="pair">
			<p class="question">28.Что такое замыкание?</p>
			<p class="answer">
				Замыкание (closure) – это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. Но в JavaScript есть небольшая терминологическая особенность. Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.<br>
				«Понимать замыкания» в JavaScript означает понимать следующие следующее. Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window. При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана. При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения». Замыкания полезны тем, что позволяют связать данные (лексическое окружение) с функцией, которая работает с этими данными.
			</p>
		</div>
		<div class="pair">
			<p class="question">29.Далее указан полный код программы. Что мы увидим в консоли браузера? Почему? Что может вернуть функция makeNoize? Почему при выполнении указанного кода возникают ошибки?</p>
			<p class="answer">
				Данный код вернет в консоль undefined. Потому что функция еще не была вызвана. Функция makeNoize может вернуть любое зачение (строку или число) если вызвать ее makeNoize() и записать в скобках это значение.
				(1) Переменные объявлены внутри функции, то есть их область видимости ограничена функцией. И вызванный console.log просто не находит их. Поэтому console.log должен быть вызван внутри функции. Его так же можно заменить на директиву return. И при вызове функции появится то же сообщение.<br>
				(2) Переменную number нельзя переопределить, так как она объявлена с помощью ключевого слова const. Нужно использовать для объявления переменной number ключевое слово let, которое дает возмозможность переопределить переменную, записав название и значение переменной без ключевого слова.<br>
				(3) Первая функция создана с помощью Function Expression, то есть ее нельзя вызвать до объявления. А вторая функция создана с помощью Function Declaration, то есть создается интерпретатором до выполнения кода, поэтому ее можно вызвать раньше объявления.<br>
				(4) console.log, вызванный после функции, не найдет переменную surname. Из-за того, что она объявлена в функции у которой своя локальная область видимости.<br>
			</p>
		</div>
		<div class="pair">
			<p class="question">30.Как можно добавить свойства или методы у объекта? Как можно удалить свойство или метод?</p>
			<p class="answer">
				Существует три способа добавления свойств у объекта. Первый – перечислить «свойство: значение» в теле объекта, через запятую каждая пара. Второй – через точку указать имяОбъекта.новоеСвойство и приравнять ему значение. Третий – определить новые свойства как отдельные переменные со значением, и потом указать имена этих переменных в теле объекта через запятую. Для удаления свойства или объекта используем оператор delete потом указываем имяОбъекта.имяСвойства/имяМетода.
			</p>
		</div>
		<div class="pair">
			<p class="question">31.Как можно перебирать свойства объектов?</p>
			<p class="answer">
				Начиная с ECMAScript 5 свойства объектов можно перебрать с помощью: цикла for…in, метода Object.keys(o), метода Object.getOwnPropertyNames(o).<br>
				Цикл for…in (for (key in obj) { } При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key и вызвано тело цикла.) перебирает все перечисляемые свойства объекта и его цепочку прототипов. Вспомогательную переменную key можно объявить прямо в цикле.<br>
				Метод Object.keys(o) возвращает массив со всеми собственными (те, что в цепочке прототипов, не войдут в массив) именами перечисляемых свойств объекта «о».<br>
				Метод Object.getOwnPropertyNames(o) возвращает массив содержащий все имена своих свойств (перечисляемых и не перечисляемых) объекта «о».
			</p>
		</div>
		<div class="pair">
			<p class="question">32.Что такое прототипное наследование?</p>
			<p class="answer">
				В JavaScript есть встроенное «наследование» между объектами при помощи специального свойства __proto__. Это скрытое системное свойство, и не во всех реализациях языка оно доступно пользователю. При установке свойства rabbit.__proto__ = animal говорят, что объект animal будет «прототипом» rabbit. При чтении свойства из объекта, если его в нём нет, оно ищется в __proto__. Прототип задействуется только при чтении свойства. Операции присвоения obj.prop = или удаления delete obj.prop совершаются всегда над самим объектом obj. Несколько прототипов одному объекту присвоить нельзя, но можно организовать объекты в цепочку (prototype chain), когда один объект ссылается на другой при помощи __proto__, тот ссылается на третий, и так далее.<br>
				Так как свойство __proto__ является скрытым, и не описано в спецификации языка, то использование его в явном виде некорректно. Однако в последней (действующей) спецификации ECMA Script 5 наконец-то появились два метода, позволяющие манипулировать свойством __proto__, это Object.create, Object.setPrototypeOf(obj, proto) и Object.getPrototypeOf.<br>
				Object.create(proto, descriptors) - создаёт пустой объект с __proto__, равным первому аргументу, второй необязательный аргумент может содержать дескрипторы свойств.<br>
				Метод Object.setPrototypeOf(obj, prototype) устанавливает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта в другой объект или null. obj  - Объект, которому устанавливается прототип. prototype - Новый прототип объекта (объект или null).<br>
				Метод Object.getPrototypeOf(obj) возвращает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта. Obj - Объект, чей прототип будет возвращён. В ES5, если параметр obj не является объектом, будет выброшено исключение TypeError. В ES6, параметр будет приведён к объекту Object.<br>
				Изменение прототипа [[Prototype]] объекта является, по самой природе оптимизации доступа к свойствам в современных движках JavaScript, очень медленной операцией, это справедливо для любого браузера и движка JavaScript. Изменение прототипов очень тонко и обширно влияет на производительность, причём это влияние не ограничивается просто временем, проведённым внутри метода Object.setPrototypeOf(), оно может распространяться на любой код, который имеет доступ к любомуобъекту, чей прототип [[Prototype]] был изменён. Если вы заботитесь о производительности, вы никогда не должны изменять прототип [[Prototype]] объекта. Вместо этого создайте объект с нужным прототипом [[Prototype]], с помощью метода Object.create().
			</p>
		</div>
		<div class="pair">
			<p class="question">33.Как можно обратиться к свойству с именем my-SoMe-PROPERTY+name?</p>
			<p class="answer">
				Имена свойств объекта могут быть строками JavaScript, или тем, что может быть сконвертировано в строку, включая пустую строку. Как бы то ни было, доступ к любому имени свойства, которое содержит невалидный JavaScript идентификатор (например, имя свойства содержит в себе пробел и тире или начинается с цифры), может быть получен с использованием квадратных скобок. Этот способ записи также полезен, когда имена свойств должны быть динамически определены (когда имя свойства не определено до момента исполнения).<br>
				имяОбъекта[“my-SoMe-PROPERTY+name”]<br>
				Все ключи с квадратными скобками преобразуются в тип String, поскольку объекты в JavaScript могут иметь в качестве ключа только тип String. 
			</p>
		</div>
		<div class="pair">
			<p class="question">34.Объясни, что такое деструктуризация.</p>
			<p class="answer">
				Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части. <br>
				Синтаксис:<br>
				let {prop : varName = default, ...} = object<br>
				Здесь двоеточие : задаёт отображение свойства prop в переменную varName, а равенство =default задаёт выражение, которое будет использовано, если значение отсутствует (не указано или undefined).<br>Для массивов имеет значение порядок, поэтому нельзя использовать :, но значение по умолчанию – можно:<br>
				let [var1 = default, var2, ...rest] = array<br>
				Объявление переменной в начале конструкции не обязательно. Можно использовать и существующие переменные. Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки. Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.
			</p>
		</div>
		<div class="pair">
			<p class="question">35.Почему при выполнении указанного кода возникают ошибки?</p>
			<p class="answer">
				Пропущен контекстный вызов (this) для доступа из метода к свойству age, принадлежащего текущему объекту  cat. При вызове метода не объявлено имя объекта, в котором он указан (cat.doMeow()).
			</p>
		</div>
	</div>
</body>
</html>