<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Answers</title>
</head>
<body>
	<div class="faq">
		<div class="pair">
			<p class="question">1.Что такое EcmaScript?</p>
			<p class="answer">
				EcmaScript содержит правила, сведения и рекомендации, которые должны соблюдаться скриптовым языком, чтобы он считался совместимым с EcmaScript. EcmaScript - это стандарт языка JavaScript. То есть это спецификация на которой основан JavaScript. А уже из документации JavaScript можно узнать как использовать скриптовый язык.
			</p>
		</div>
		<div class="pair">
			<p class="question">2.Для чего используются и чем отличаются атрибуты async и defer?</p>
			<p class="answer">
				async и defer - это атрибуты тега script, для которых не указываются значения. Оба они используются для примитивной регулировки загрузки скриптов, но существуют и более продвинутые. async - загружает скрипт параллельно с загрузкой остального контента. Скрипт выполнится как только будет загружен. defer - выполняет скрипт только после полной загрузки страницы, и сохраняет очередность выполнения.
			</p>
		</div>
		<div class="pair">
			<p class="question">3.Почему предпочтительнее подключать скрипты перед &lt;/body&gt;, а не в &lt;head&gt;...&lt;/head&gt;?</p>
			<p class="answer">
				Предпочтительнее подключать скрипты перед &lt;/body&gt;, так как скрипты начнут грузится после загрузки основного контента. Если же подключить скрипт в &lt;head&gt;...&lt;/head&gt;, то сначала будут грузиться все скрипты и только потом остальной контент. В &lt;head&gt;...&lt;/head&gt; подключается тот скрипт, который важен для работы всех скриптов, а перед &lt;/body&gt; - для быстрой загрузки страницы в браузере. Очередность подключения тоже важна.
			</p>
		</div>
		<div class="pair">
			<p class="question">4.Какие основные отличия интерпретируемого языка программирования от компилируемого?</p>
			<p class="answer">
				Для использования компилируемых языков (C, C++, Go, Haskell, Rust) необходим компилятор, который переведет программу в понятный для машины код и только после этого код будет исполнен в операционной системе. Поскольку они конвертируются в машинный код, они работают гораздо быстрее и эффективнее, чем интерпретируемые. Но недостатком является то, что для тестирования любого изменения программу нужно заново компилировать, и такие языки платформо-зависимые (поскольку машинный код зависит от машины, на которой компилируется и исполняется программа). Интерпретируемые (JavaScript, PHP, Perl, Ruby, Python) же языки не нуждаются в переводе, нужна только программа-интерпретатор, которая исполнит код построчно вместо операционной системы. Плюсы их использования: независимость от платформы, рефлексия, динамическая типизация, меньший размер исполняемых файлов, динамические области видимости. Основным недостатком интерпретируемых языков является их невысокая скорость исполнения. Многие языки программирования имеют как компилируемую, так и интерпретируемую версии.
			</p>
		</div>
		<div class="pair">
			<p class="question">5.Что такое языки высокого и низкого уровня? Какие ты знаешь?</p>
			<p class="answer">
				Языки программирования низкого уровня - это те, которые имеют прямой доступ к памяти и регистрам, и позволяют задавать машинные команды в понятном для человека виде. Для преобразования их в двоичный код были созданы специальные программы — трансляторы (компиляторы и интерпретаторы). Языки низкого уровня ориентированы на конкретный тип процессора и учитывают его особенности, поэтому для переноса программы на другую аппаратную платформу её нужно почти полностью переписать. Определенные различия есть и в синтаксисе программ под разные компиляторы. Примерами таких языков программирования являются: Ассемблер, CIL, Forth. Высокоуровневый язык программирования — язык программирования, разработанный для быстроты и удобства использования программистом. Особенности конкретных компьютерных архитектур в них не учитываются, поэтому созданные приложения легко переносятся с компьютера на компьютер. В большинстве случаев достаточно просто перекомпилировать программу под определенную компьютерную архитектурную и операционную систему. Примерами таких языков программирования являются: C++, C#, Visual Basic, Python, Perl, Fortran, Delphi и др..
			</p>
		</div>
		<div class="pair">
			<p class="question">6.Для чего используются переменные? Какие ключевые слова используются для создания переменных? Какие есть отличия в переопределении значений при задании переменной через let, const и var?</p>
			<p class="answer">
				Переменные используются для записи значения, чтобы в дальнейшем его использовать. Ключевыми словами для создания переменных являются var, let и const. var - устаревший способ, так как переменную, заданную им, легко можно переопределить (изменить значение) и может возникнуть путаница. Переменную заданную с помощью const нельзя переопределить. А переменную заданную через let нельзя прямо переопределить (для этого нужно записать название и значение переменной без ключевого слова).
			</p>
		</div>
		<div class="pair">
			<p class="question">7.Может ли имя переменной начинаться с цифры, символов _ или $?</p>
			<p class="answer">
				Имя переменной не может начинаться с цифры (цифры могут входить в его состав). Но может начинаться и состоять из символов _ или $ (другие символы использовать неправильно).
			</p>
		</div>
		<div class="pair">
			<p class="question">8.Какие слова запрещено использовать в названии переменной?</p>
			<p class="answer">
				В названии переменной запрещено использовать слова, которые используются самим языком программирования. Например, const, let, class, return, export и другие. Существует целый список таких зарезервированных слов. В названии переменных можно использовать и русские буквы, но это не рекомендуется. Также не используется транслит!
			</p>
		</div>
		<div class="pair">
			<p class="question">9.Что такое camelCase и snake_case?</p>
			<p class="answer">
				Переменные, состоящие из нескольких слов, пишутся с использованием записи camelCase или snake_case. При использовании записи camelCase несколько слов пишутся слитно без пробелов, при этом каждое слово внутри фразы пишется с прописной буквы (например, borderLeftWidth). Существует альтернативный стандарт, когда несколько слов пишутся через знак подчеркивания '_' - это так называемый snake_case. Преимущественно в JavaScript используется camelCase.
			</p>
		</div>
		<div class="pair">
			<p class="question">10.Что такое "типы данных"? Какой оператор позволяет определить тип данных?</p>
			<p class="answer">
				В программировании тип данных это множество допустимых значений, которые могут принимать данные, принадлежащие к этому типу. Чтобы иметь возможность работать с переменной, важно знать ее тип. В JavaScript существует несколько основных типов данных. Они делятся на примитивные (числа (numbers), строки (strings), логические (boolean), символ (symbol), null, udefined) и сложные (объекты (objects), массивы (arrays), функции (functions)). typeof - оператор, позволяющий определить тип данных.
			</p>
		</div>
		<div class="pair">
			<p class="question">11.Что такое "динамическое приведение типов данных"? Можно ли писать JavaScript со статическим приведением типов?</p>
			<p class="answer">
				Динамическое приведение типов данных - это процесс преобразования значений переменной из одного типа в другой, при этом определение типа переменной происходит не во время ее объявления, а когда ей присвается конкретное значение при запуске. JavaScript - язык с динамической типизацией. Но писать JavaScript со статическим приведением типов можно. Для этого используются инструменты вроде Flow и TypeScript. Flow — это open source библиотека для статической проверки типов, которую разработала и выпустила Facebook. Она позволяет постепенно добавлять типы в код JavaScript. TypeScript - новый язык программирования со статической типизацией (указание типа переменной при её объявлении). TypeScript представляет собой надмножество, которое компилируется в JavaScript (то есть, любой код на JS является правильным с точки зрения TypeScript). Но перед его использованием нужно очень хорошо изучить полную систему типов и как наилучшим образом их выбирать в программе. Также из-за статических типов программы часто выглядят более многословными и загроможденными, соответственно на их написание тратится больше времени. Плюсами является: возможность писать меньше тестов — все параметры методов жестко описаны, и если код скомпилировался, тогда, вероятно, каждый вызов является валидным, и не требует дополнительной проверки; скорость выполнения; при некоторых дополнительных условиях, позволяет обнаруживать потенциальные ошибки уже на этапе компиляции.
			</p>
		</div>
		<div class="pair">
			<p class="question">12.Как привести строчное значение "10" к числу? Назовите два способа.</p>
			<p class="answer">
				Для преобразования строчного значения "10" к числу в явном виде можно вызвать Number('10'), либо, что короче, поставить перед выражением унарный плюс '+': +'10'.
			</p>
		</div>
		<div class="pair">
			<p class="question">13.Чем отличаются операторы "==" и "==="?</p>
			<p class="answer"
			>== это оператор не строгого сравнения, а === оператор строгого. Оператор строгого сравнения учитывает не только значение переменной, но и тип данных (то есть, если значение совпадает, а тип данных нет, то будет считаться, что равенства нет).
		</p>
		</div>
		<div class="pair">
			<p class="question">14.Какие преимущества дают обратные кавычки (`) при указании строки?</p>
			<p class="answer">
				Обратные кавычки дают возможность использовать интерполяцию. Интерполяция позволяет использовать переменные или выражения в строке и легко переносить строку.
			</p>
		</div>
		<div class="pair">
			<p class="question">15.Что такое "алгоритм"? Какие ты знаешь типы алгоритмов?</p>
			<p class="answer">
				Алгоритм – это набор инструкций, описывающих порядок действий исполнителя для достижения некоторого результата. Существуют такие типы алгоритмов: линейный (состоит из команд, выполняемых последовательно во времени друг за другом), разветвленный (условный - содержит хотя бы одно условие, в результате которого может осуществляться разделение на несколько альтернативных ветвей алгоритма), циклический (предусматривает многократное повторение одного и того же действия над новыми исходными данными).
			</p>
		</div>
		<div class="pair">
			<p class="question">16.Зачем нужны циклы? Какие виды циклов ты знаешь? В чем их основные отличия?</p>
			<p class="answer">
				Циклы используются для многократного повторения одного участка кода (выполнения повторяющихся вычислений). Они оптимизируют процесс написания кода. Существуют такие виды циклов: while, do…while (редко используются, т.к. считается, что они сложнее воспринимаются визуально), for (используются чаще всего), for…in, бесконечный цикл и вложенный цикл. Цикл while проверяет условие, и если оно приравнивается к true, то тело цикла выполняется. Цикл do…while сначала выполняет тело, а уже потом проверяет соответствие условию. Цикл for проверяет условие перед каждой итерацией, пока не произойдет какое-либо специальное событие завершения цикла. Цикл for…in проходит через перечисляемы свойства объекта. Он пройдет по каждому отдельному элементу.
			</p>
		</div>
		<div class="pair">
			<p class="question">17.Что делают операторы ++i и i++ и в чем их отличие?</p>
			<p class="answer">
				Операторы ++i и i++ (более короткая запись для i = i + 1) – это инкремент, который используется для увеличения числа на 1. Инкремент можно применить только к переменной и использовать для любых выражений! ++i – его префиксная форма, а i++ - постфиксная. Отличаются они тем, что постфиксная форма возвращает старое значение (до увеличения на 1), а префиксная форма сразу возвращает увеличенное значение. Если результат оператора не используется, а нужно только увеличить переменную – без разницы, какую форму использовать. Эта разница видна только если результат оператора сразу используется. Тоже самое для декремента (--i, i--), который используется для уменьшения числа на 1.
			</p>
		</div>
		<div class="pair">
			<p class="question">18.Что такое "итерация"?</p>
			<p class="answer">
				Итерация – это каждое повторение цикла.
			</p>
		</div>
		<div class="pair">
			<p class="question">19.Как называются и чем отличаются операторы || и &&?</p>
			<p class="answer">
				|| и && - это логические операторы, но в JavaScript могут применяться к значениям любого типа и возвращают также значения любого типа. || - оператор "ИЛИ", && - оператор "И". Оператор || вычисляет операнды слева направо до первого "истинного" (true) и возвращает его ("короткий цикл вычисления"), а если все ложные (false) – то последнее значение. Причём, не преобразованное к логическому типу. Обычно оператор || используется в if, чтобы проверить, выполняется ли хотя бы одно из условий. Оператор && вычисляет операнды слева направо до первого «ложного» (false) и возвращает его, а если все истинные (true) – то последнее значение. Как и в ИЛИ, в И допустимы любые значения. То есть к операторам || и && применяется принцип "короткого цикла вычислений", но немного отличающийся.
			</p>
		</div>
		<div class="pair">
			<p class="question">20.Для чего используется break? Почему в конструкции switch нужно использовать break для каждого case?</p>
			<p class="answer">
				Директива break используется для выхода из цикла. Если не указан break после каждого case, то выполнение цикла пойдет ниже по следующим case, при этом остальные проверки игнорируются.
			</p>
		</div>
		<div class="pair">
			<p class="question">21.Почему при выполнении указанного кода возникают ошибки?</p>
			<p class="answer">
				(1) Это бесконечный цикл. Чтобы избежать создания бесконечного цикла, нужно убедиться, что заданное условие в какой-то момент вернёт false. Заданное условие никогда не вернет false, потому что переменная i всегда будет равна 0 и соответственно меньше 10.<br>
				(2) Лишняя точка с запятой (;) перед телом цикла (перед фигурной скобкой). Пропущено ключевое слово let перед объявлением переменной.<br>
				(3) Не указан break после каждого условия, то есть цикл не будет останавливаться на правильном варианте а будет выполняться до конца, при этом остальные проверки игнорируются.<br>
				(4) Вводимое пользователем число считается строкой. Нужно чтобы переменная считывалась как числовая, а не строчная. Это можно исправить, добавив унарный "+" перед prompt.<br>
			</p>
		</div>
		<div class="pair">
			<p class="question">22.Зачем нужны функции?</p>
			<p class="answer">
				Функции нужны для повторения одного и того же кода в разных частях программы, чтобы не писать его многократно. Функция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие.
			</p>
		</div>
		<div class="pair">
			<p class="question">23.Сколько параметров можно передать функции?</p>
			<p class="answer">
				При вызове функции ей можно передать данные, которые та использует по своему усмотрению. Параметры копируются в локальные переменные функции. Параметров можно передавать больше или меньше, чем необходимо. То есть функцию можно вызвать с любым количеством параметров. Не будет никакой ошибки. Если параметр не передан при вызове – он считается равным undefined.
			</p>
		</div>
		<div class="pair">
			<p class="question">24.Что случится, если передать в функцию меньше параметров, чем нужно? А если больше? Объясни на примере функции add(a, b).</p>
			<p class="answer">
				Параметры функции – такие же переменные, но их начальные значения задаются при вызове функции, а не в её коде. Если не передать в функцию параметр a или b, то непереданные будут считаться равными undefined. А если передать в функцию add больше параметров чем 2 ошибки не произойдет. Но, чтобы получить такие «лишние» аргументы, нужно будет прочитать их из специального объекта arguments. Он содержит список аргументов по номерам: arguments[0], arguments[1]…, а также свойство length. Все параметры находятся в arguments, даже если они есть в списке. arguments – это не массив Array. В действительности, это обычный объект, просто ключи числовые и есть length. На этом сходство заканчивается. Никаких особых методов у него нет, и методы массивов он тоже не поддерживает. В старом стандарте JavaScript псевдо-массив arguments и переменные-параметры ссылаются на одни и те же значения. То есть в результате изменения arguments влияют на параметры и наоборот.В современной редакции стандарта это поведение изменено. Аргументы отделены от локальных переменных.
			</p>
		</div>
		<div class="pair">
			<p class="question">25.Возможно ли для параметра указать значение по умолчанию? Назови два способа?</p>
			<p class="answer">
				Для параметра функции можно указать значение по умолчанию. Для этого используется два способа. Первый способ: проверть с помощью оператора if равен ли аргумент undefined, и если да – то записать в него значение по умолчанию. Второй способ: использовать оператор || (запись выглядит так: text = text || 'текст не передан';). То есть считается, что аргумент отсутствует, если передана пустая строка, 0, или вообще любое значение, которое в логическом контексте является false. Также можно указывать параметры по умолчанию через "=" в списке параметров в скобках после имени функции. Параметр по умолчанию используется при отсутствующем аргументе или равном undefined. При передаче любого значения, кроме undefined, включая пустую строку, ноль или null, параметр считается переданным, и значение по умолчанию не используется. Параметры по умолчанию могут быть не только значениями, но и выражениями.
			</p>
		</div>
		<div class="pair">
			<p class="question">26.Что такое область видимости?</p>
			<p class="answer">
				Переменные объявленные внутри функции нельзя вызвать вне. То есть внутри функции создается локальная область видимости. Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных. При объявлении переменной в таких блоках, она всё равно будет видна во всей функции. Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию. Переменные, объявленные на уровне всего скрипта, называют «глобальными переменными». Функция может обратиться к таким внешним переменным. Доступ возможен не только на чтение, но и на запись. При этом, так как переменная внешняя, то изменения будут видны и снаружи функции.
			</p>
		</div>
		<div class="pair">
			<p class="question">27.Чем отличается Function Declaration от Function Expression?</p>
			<p class="answer">
				 Function Declaration от Function Expression это синтаксисы для объявления функции. Функции, созданные с помощью Function Declaration создаются интерпретатором до выполнения кода, поэтому их можно вызвать раньше объявления (такое поведение называют термином "поднятие" (hoisting)). Так же их не используют для условного объявление в if. А функции, созданные с помощью Function Expression нельзя вызвать до оглашения, потому что интерпретатор создает их, когда доходит до строчки кода в которой записана функция. И они работают в if.
			</p>
		</div>
		<div class="pair">
			<p class="question">28.Что такое замыкание?</p>
			<p class="answer">
				Замыкание (closure) – это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. Но в JavaScript есть небольшая терминологическая особенность. Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.<br>
				«Понимать замыкания» в JavaScript означает понимать следующие следующее. Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window. При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана. При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения». Замыкания полезны тем, что позволяют связать данные (лексическое окружение) с функцией, которая работает с этими данными.
			</p>
		</div>
		<div class="pair">
			<p class="question">29.Далее указан полный код программы. Что мы увидим в консоли браузера? Почему? Что может вернуть функция makeNoize? Почему при выполнении указанного кода возникают ошибки?</p>
			<p class="answer">
				Данный код вернет в консоль undefined. Потому что функция еще не была вызвана. Функция makeNoize может вернуть любое зачение (строку или число) если вызвать ее makeNoize() и записать в скобках это значение.
				(1) Переменные объявлены внутри функции, то есть их область видимости ограничена функцией. И вызванный console.log просто не находит их. Поэтому console.log должен быть вызван внутри функции. Его так же можно заменить на директиву return. И при вызове функции появится то же сообщение.<br>
				(2) Переменную number нельзя переопределить, так как она объявлена с помощью ключевого слова const. Нужно использовать для объявления переменной number ключевое слово let, которое дает возмозможность переопределить переменную, записав название и значение переменной без ключевого слова.<br>
				(3) Первая функция создана с помощью Function Expression, то есть ее нельзя вызвать до объявления. А вторая функция создана с помощью Function Declaration, то есть создается интерпретатором до выполнения кода, поэтому ее можно вызвать раньше объявления.<br>
				(4) console.log, вызванный после функции, не найдет переменную surname. Из-за того, что она объявлена в функции у которой своя локальная область видимости.<br>
			</p>
		</div>
		<div class="pair">
			<p class="question">30.Как можно добавить свойства или методы у объекта? Как можно удалить свойство или метод?</p>
			<p class="answer">
				Существует три способа добавления свойств у объекта. Первый – перечислить «свойство: значение» в теле объекта, через запятую каждая пара. Второй – через точку указать имяОбъекта.новоеСвойство и приравнять ему значение. Третий – определить новые свойства как отдельные переменные со значением, и потом указать имена этих переменных в теле объекта через запятую. Для удаления свойства или объекта используем оператор delete потом указываем имяОбъекта.имяСвойства/имяМетода.
			</p>
		</div>
		<div class="pair">
			<p class="question">31.Как можно перебирать свойства объектов?</p>
			<p class="answer">
				Начиная с ECMAScript 5 свойства объектов можно перебрать с помощью: цикла for…in, метода Object.keys(o), метода Object.getOwnPropertyNames(o).<br>
				Цикл for…in (for (key in obj) { } При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key и вызвано тело цикла.) перебирает все перечисляемые свойства объекта и его цепочку прототипов. Вспомогательную переменную key можно объявить прямо в цикле.<br>
				Метод Object.keys(o) возвращает массив со всеми собственными (те, что в цепочке прототипов, не войдут в массив) именами перечисляемых свойств объекта «о».<br>
				Метод Object.getOwnPropertyNames(o) возвращает массив содержащий все имена своих свойств (перечисляемых и не перечисляемых) объекта «о».
			</p>
		</div>
		<div class="pair">
			<p class="question">32.Что такое прототипное наследование?</p>
			<p class="answer">
				В JavaScript есть встроенное «наследование» между объектами при помощи специального свойства __proto__. Это скрытое системное свойство, и не во всех реализациях языка оно доступно пользователю. При установке свойства rabbit.__proto__ = animal говорят, что объект animal будет «прототипом» rabbit. При чтении свойства из объекта, если его в нём нет, оно ищется в __proto__. Прототип задействуется только при чтении свойства. Операции присвоения obj.prop = или удаления delete obj.prop совершаются всегда над самим объектом obj. Несколько прототипов одному объекту присвоить нельзя, но можно организовать объекты в цепочку (prototype chain), когда один объект ссылается на другой при помощи __proto__, тот ссылается на третий, и так далее.<br>
				Так как свойство __proto__ является скрытым, и не описано в спецификации языка, то использование его в явном виде некорректно. Однако в последней (действующей) спецификации ECMA Script 5 наконец-то появились два метода, позволяющие манипулировать свойством __proto__, это Object.create, Object.setPrototypeOf(obj, proto) и Object.getPrototypeOf.<br>
				Object.create(proto, descriptors) - создаёт пустой объект с __proto__, равным первому аргументу, второй необязательный аргумент может содержать дескрипторы свойств.<br>
				Метод Object.setPrototypeOf(obj, prototype) устанавливает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта в другой объект или null. obj  - Объект, которому устанавливается прототип. prototype - Новый прототип объекта (объект или null).<br>
				Метод Object.getPrototypeOf(obj) возвращает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта. Obj - Объект, чей прототип будет возвращён. В ES5, если параметр obj не является объектом, будет выброшено исключение TypeError. В ES6, параметр будет приведён к объекту Object.<br>
				Изменение прототипа [[Prototype]] объекта является, по самой природе оптимизации доступа к свойствам в современных движках JavaScript, очень медленной операцией, это справедливо для любого браузера и движка JavaScript. Изменение прототипов очень тонко и обширно влияет на производительность, причём это влияние не ограничивается просто временем, проведённым внутри метода Object.setPrototypeOf(), оно может распространяться на любой код, который имеет доступ к любомуобъекту, чей прототип [[Prototype]] был изменён. Если вы заботитесь о производительности, вы никогда не должны изменять прототип [[Prototype]] объекта. Вместо этого создайте объект с нужным прототипом [[Prototype]], с помощью метода Object.create().
			</p>
		</div>
		<div class="pair">
			<p class="question">33.Как можно обратиться к свойству с именем my-SoMe-PROPERTY+name?</p>
			<p class="answer">
				Имена свойств объекта могут быть строками JavaScript, или тем, что может быть сконвертировано в строку, включая пустую строку. Как бы то ни было, доступ к любому имени свойства, которое содержит невалидный JavaScript идентификатор (например, имя свойства содержит в себе пробел и тире или начинается с цифры), может быть получен с использованием квадратных скобок. Этот способ записи также полезен, когда имена свойств должны быть динамически определены (когда имя свойства не определено до момента исполнения).<br>
				имяОбъекта[“my-SoMe-PROPERTY+name”]<br>
				Все ключи с квадратными скобками преобразуются в тип String, поскольку объекты в JavaScript могут иметь в качестве ключа только тип String. 
			</p>
		</div>
		<div class="pair">
			<p class="question">34.Объясни, что такое деструктуризация.</p>
			<p class="answer">
				Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части. <br>
				Синтаксис:<br>
				let {prop : varName = default, ...} = object<br>
				Здесь двоеточие : задаёт отображение свойства prop в переменную varName, а равенство =default задаёт выражение, которое будет использовано, если значение отсутствует (не указано или undefined).<br>Для массивов имеет значение порядок, поэтому нельзя использовать :, но значение по умолчанию – можно:<br>
				let [var1 = default, var2, ...rest] = array<br>
				Объявление переменной в начале конструкции не обязательно. Можно использовать и существующие переменные. Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки. Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.
			</p>
		</div>
		<div class="pair">
			<p class="question">35.Почему при выполнении указанного кода возникают ошибки?</p>
			<p class="answer">
				Пропущен контекстный вызов (this) для доступа из метода к свойству age, принадлежащего текущему объекту  cat. При вызове метода не объявлено имя объекта, в котором он указан (cat.doMeow()).
			</p>
		</div>
		<div class="pair">
			<p class="question">36.Что такое массив?</p>
			<p class="answer">
				Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией. Они обычно используются для хранения упорядоченных коллекций данных, например – списка товаров на странице, студентов в группе и т.п.
			</p>
		</div>
		<div class="pair">
			<p class="question">37.Чем массив отличается от объекта?</p>
			<p class="answer">
				Для объекта последовательность информации не важна, этот тип данных больше всего подходит для структурирования информации по названию данных. Объекты хранят информацию в виде пары ключ-значение. Поэтому когда легче получить доступ к данным на основании их имён (ключа), то необходимо хранить эти данные в виде объекта. А массив используется тогда, когда последовательность информации имеет большое значение. Когда нужно перебрать массив, то используется номер для каждого элемента массива. Массивы — это структуры данных, где нумерация начинается с нуля. То есть к первому элементу обращаемся так: имяМассива[0]. <br>
				При использовании оператора delete для удаления элемента из массива, на месте элемента остается дырка. В случае с объектом пустое место не остается. Так что для удаления элемента массива лучше всего использовать методы pop (для последнего элемента), shift (для первого элемента) или splice (для значения отличного от первого или последнего. Синтаксис: arrayName.splice(начальный индекс, сколько удалить, элементы, которые будут подставлены в массив)).
			</p>
		</div>
		<div class="pair">
			<p class="question">38.Что такое callback?</p>
			<p class="answer">
				callback - это функция обратного вызова, которая передается в качестве аргумента другой функции и выполняется после выполнения основного кода.
			</p>
		</div>
		<div class="pair">
			<p class="question">39.Чем отличаются методы Array.of и Array.from?</p>
			<p class="answer">
				Методы Array.of и Array.from преобразуют полученные элементы в массив. Они отличаются тем, что Array.of() принимает неограниченное число аргументов и превращает их все в массив, Array.from() принимает callback в качестве второго аргумента.
			</p>
		</div>
		<div class="pair">
			<p class="question">40.Как можно узнать длину массива?</p>
			<p class="answer">
				Длинну массива можно узнать с помощью свойства length. Длинна length - не количество элементов массива, а индекс последнего элемента + 1. Это свойство также позволяет укорачивать массив: arrayName.length = колличество оставшихся элементов. Причем этот процесс необратимый, то есть даже если потом вернуть length обратно – значения не восстановятся.
			</p>
		</div>
		<div class="pair">
			<p class="question">41.Почему методы pop/push быстрее, чем shift/unshift?</p>
			<p class="answer">
				Метод push добавляет новый элемент в конец массива, а unshift - в начало массива. Метод pop удаляет последний элемент и возвращает его, а shift - первый и возвращает его (это означает, что можно "поймать" удаленный элемент и поместить в переменную.). Методы pop/push выполняются быстрее, чем shift/unshift, потому что для добавления или удаления элемента сначала массива нужно еще и переместить элементы на их новые индексы, и изменить значение length. Чем больше элементов в массиве, тем дольше их перемещать, это много операций с памятью. А перемещать при pop не требуется, так как прочие элементы после этой операции остаются на тех же индексах и уменьшается значение length. Аналогично работает push.
			</p>
		</div>
		<div class="pair">
			<p class="question">42.Дополни следующий код. 1) Как обратиться к свойству name? 2) Как задать свойство age равное 41?</p>
			<p class="answer">
				(1) user[0].name;<br>
				(2) user[0].age = 41;<br> 
			</p>
		</div>
		<div class="pair">
			<p class="question">43.Что такое DOM?</p>
			<p class="answer">
				Сам по себе язык JavaScript не предусматривает работы с браузером. Он вообще не знает про HTML. Но позволяет легко расширять себя новыми функциями и объектами.
				DOM (Document Object Model) - это представление HTML-документа в виде дерева объектов, доступное для изменения через JavaScript. Из DOM легко можно управлять содержимым, стилями, значениями атрибутов. У элементов DOM есть свойства и методы, которые позволяют изменять их. Кстати, DOM-модель (внутреннее представление HTML-страницы в виде дерева) используется не только в JavaScript, это известный способ представления XML-документов. В мире DOM в качестве значения, обозначающего «нет такого элемента» или «узел не найден», используется не undefined, а null.
			</p>
		</div>
		<div class="pair">
			<p class="question">44.Что такое узел (нода)? Какие существуют ноды?</p>
			<p class="answer">
				Каждый HTML-тег образует узел (ноду) дерева с типом «элемент». Вложенные в него теги становятся дочерними узлами. Для представления текста создаются узлы с типом «текст». Всего различают 12 типов узлов. Самыми основными являются четыре: документ (точка входа в DOM), узлы-элементы (element node), текстовые узлы (text node) и комментарии (иногда в них можно включить информацию, которая не будет показана, но доступна из JS). Теги образуют узлы-элементы (element node). Естественным образом одни узлы вложены в другие. Структура дерева образована исключительно за счет них. Текст внутри элементов образует текстовые узлы (text node). Текстовый узел содержит исключительно строку текста и не может иметь потомков, то есть он всегда на самом нижнем уровне. Пробелы и переводы строки – это тоже текст, полноправные символы, которые учитываются в DOM. Но на самом верхнем уровне из этого правила есть исключения: пробелы до &lt;head&gt; по стандарту игнорируются, а любое содержимое после &lt;/body&gt; не создаёт узла, браузер переносит его внутрь, в конец body.
			</p>
		</div>
		<div class="pair">
			<p class="question">45.Какие есть способы поиска элементов на странице?</p>
			<p class="answer">
				Существует поиск элементов по классу (document.getElementsByClassName()), по тегу (document.getElementsByTagName()) или идентификатору (document.getElementById()). document.getElementsByClassName(classNames: DOMString) - принимает в качестве аргумента любой класс и возвращает коллекцию (похожа на массив, поскольку имеет индексы и к ним можно обратиться, как к обычному массиву. Но отсутствуют методы массивов и для перебора используют цикл for). document.getElementsByTagName(classNames: DOMString) - принимает в качестве аргумента любой тег и возвращает коллекцию. Можно получить всех потомков, передав звездочку '*' вместо тега. document.getElementById(classNames: DOMString) - принимает в качестве аргумента идентификатор и возвращает элемент (ноду). <br>
				Более продвинутыми методами являются document.querySelectorAll() и document.querySelector(). document.querySelectorAll(selectors: DOMString) - принимает в качестве аргумента любой CSS-селектор и возвращает NodeList (в отличии от коллекции, имеет в прототипе некоторые удобные методы). document.querySelector(selectors: DOMString) - принимает в качестве аргумента любой CSS-селектор и возвращает первый найденный на странице элемент. И является аналогом document.querySelectorAll('.someclass')[0], но работает быстрее. При использовании этих двух методов можно перебирать полученный псевдомассив при помощи forEach. Псевдо-классы в CSS-селекторе, в частности :hover и :active, также поддерживаются. Например, document.querySelectorAll(':hover') вернёт список, в порядке вложенности, из текущих элементов под курсором мыши.
			</p>
		</div>
		<div class="pair">
			<p class="question">46.Что возвращает метод document.getElementById()? А метод document.querySelectorAll()?</p>
			<p class="answer">
				Метод document.getElementById(elementId: DOMString) принимает в качестве аргумента идентификатор и возвращает элемент (ноду). И существует только в контексте document. А метод document.querySelectorAll(selectors: DOMString) принимает в качестве аргумента любой CSS-селектор и возвращает NodeList. Т.е. возвращает все элементы внутри document, удовлетворяющие CSS-селектору css. Это один из самых часто используемых и полезных методов при работе с DOM.
			</p>
		</div>
		<div class="pair">
			<p class="question">47.Как изменить стили элемента? Какая существует особенность с правилам, в названии которых есть дефис (border-radius, padding-left)? Какая особенность есть со свойством float? Можно ли задать элементу сразу несколько CSS-свойств?</p>
			<p class="answer">
				element.style.property - возвращает строку со значением указанного свойства. Свойство style содержит лишь тот стиль, который указан в атрибуте элемента, без учёта каскада CSS. Свойство currentStyle(IE8-) и метод getComputedStyle (IE9+, стандарт) позволяют получить реальное, применённое сейчас к элементу свойство стиля с учётом CSS-каскада и браузерных стилей по умолчанию. При этом currentStyle возвращает значение из CSS, до окончательных вычислений, а getComputedStyle – окончательное, непосредственно применённое к элементу (как правило).<br> 
				А element.style.property = 'value' - задает свойству указанное значение. К правилам, в названии которых есть дефис (border-radius, padding-left), обращаются, используя camelCase (т.е. borderRadius, paddingLeft и т.д.). Специфические свойства браузеров, типа -moz-border-radius, -webkit-border-radius, записываются следующим способом: button.style.MozBorderRadius. То есть, каждый дефис даёт большую букву.<br>
				Исключением является свойство float. В старом стандарте JavaScript слово "float" было зарезервировано и недоступно для использования в качестве свойства объекта. Поэтому используется не elem.style.float, а elem.style.cssFloat.<br>	
				element.style.cssText = `color: #111;` - позволяет указать сразу несколько CSS-свойств для элемента. При установке style.cssText все предыдущие свойства style удаляются.<br>
				Об этом иногда забывают, но в style так же, как и в CSS, нужно указывать единицы измерения, например px. Чтобы сбросить поставленный стиль, присваивают в style пустую строку: elem.style.width="". При сбросе свойства style стиль будет взят из CSS. В большинстве случаев внешний вид элементов задаётся классами. А JavaScript добавляет или удаляет их. Такой код красив и гибок, дизайн можно легко изменять. Свойство style нужно использовать лишь там, где классы не подходят, например если точное значение цвета/отступа/высоты вычисляется в JavaScript.
			</p>
		</div>
		<div class="pair">
			<p class="question">48.Чем отличается HTMLCollection / NodeList от массива?</p>
			<p class="answer">
				HTMLCollection (это список узлов в порядке упоминания в документе) похожа на массив, поскольку имеет индексы и к ним можно обратиться, как к обычному массиву. Но у нее отсутствуют методы массивов (такие как forEach, map, push, pop и др.) и для перебора используют цикл for. Для перебора нельзя использовать for...in, который кроме индексов будет выводить еще и лишнюю информацию (свойство length (в коллекции оно enumerable), а также функцию item(n) – она никогда не используется, возвращает n-й элемент коллекции, проще обратиться по индексу [n]). HTMLCollection, хранящая элементы DOM, является динамической. Т.е. при изменении документа она моментально отражает все произведённые изменения. Коллекция HTML всегда находится в DOM, в то время как NodeList является более универсальной конструкцией, которая может или не может быть в DOM. <br>
				NodeList (это коллекция узлов, возвращаемая такими методами, как Node.childNodes и document.querySelectorAll) все же имеет в прототипе некоторые удобные методы. Поэтому при использовании querySelector() или querySelectorAll() можно перебирать полученный псевдомассив при помощи forEach. NodeList также можно конвертировать в Array при помощи Array.from(). Объекты NodeList являются динамическими или статическимы (любые изменения в DOM не отражаются на его содержании), в зависимости от способа используемого для их получения. К примеру, document.querySelectorAll возвращает статический NodeList. Но не все объекты NodeList являются статическими. Например, document.getElementByName вернет “живой” NodeList.<br>
				Когда необходимо преобразовывать NodeList в массив? Это зависит от конкретного случая. Если нужно использовать актуальную информацию об узлах в DOM все время, то должны использоваться NodeList или HTMLCollection как есть, без преобразования в массив. <br>
				Перебор коллекции методами массива все-таки возможен: <br>
				1. Применить метод массива через call/apply. <br>
				2. При помощи Array.prototype.slice сделать из коллекции массив. Обычно вызов arr.slice(a, b) делает новый массив и копирует туда элементы arr с индексами от a до b-1 включительно. Если же вызвать его без аргументов arr.slice(), то он делает новый массив и копирует туда все элементы arr. Это работает и для коллекции.
			</p>
		</div>
		<div class="pair">
			<p class="question">49.Как обратиться к родителю элемента? А к потомку?</p>
			<p class="answer">
				Псевдо-массив childNodes хранит все дочерние элементы, включая текстовые. Доступ к элементам слева и справа данного можно получить по ссылкам previousSibling / nextSibling. Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему элементу. Родитель доступен через parentNode. Если долго идти от одного элемента к другому, то рано или поздно дойдёшь до корня DOM, то есть до document.documentElement, а затем и document. Навигационные ссылки, описанные выше, равно касаются всех узлов в документе. В частности, в childNodes сосуществуют и текстовые узлы и узлы-элементы и узлы-комментарии, если есть. Но для большинства задач текстовые узлы не интересны. <br>
				Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element: children (только дочерние узлы-элементы, то есть соответствующие тегам); firstElementChild, lastElementChild (соответственно, первый и последний дети-элементы); previousElementSibling, nextElementSibling (соседи-элементы) и parentElement (родитель-элемент). Т.е. теперь будут выводиться не все узлы, а только узлы-элементы. В IE8- поддерживается только children. В IE8- в children присутствуют узлы-комментарии. У конкретных элементов DOM могут быть свои дополнительные ссылки для большего удобства навигации (например, у таблиц и форм).
			</p>
		</div>
		<div class="pair">
			<p class="question">50.Опиши, какие методы и свойства используются для работы с классами?</p>
			<p class="answer">
				Самое главное различие между DOM-узлами – разные узлы являются объектами различных классов. DOM-узлы – обычные JavaScript-объекты. Их классы заданы в прототипном стиле. В этом легко убедиться, если вывести в консоли любой элемент через console.dir(elem) (выводит элемент в виде JavaScript-объекта, удобно для анализа его свойств). Или даже можно напрямую обратиться к методам, которые хранятся в Node.prototype, Element.prototype и так далее. <br>
				Свойство classList возвращает псевдомассив DOMTokenList, содержащий все классы элемента.
				У classList есть примитивная альтернатива - свойство className, которое содержит значение атрибута class элемента. ClassList является геттером. Возвращаемый им объект имеет несколько методов: <br>
				add( String [,String] ) - добавляет элементу указанные классы (синтаксис: element.classList.add()); 
				remove( String [,String] ) - удаляет у элемента указанные классы; 
				item ( Number ) - используется для получения класса по его индексу в списке, результат аналогичен вызову сlassList[Number]; 
				toggle ( String [, Boolean]) -  если класс у элемента отсутствует - добавляет, иначе - убирает. Когда вторым параметром передано false - удаляет указанный класс, а если true - добавляет. Если вторым параметром передан undefined или переменная с typeof == 'undefined', поведение будет аналогичным передаче только первого параметра при вызове toggle. 
				contains ( String ) - проверяет, есть ли данный класс у элемента (вернет true или false).
				И, конечно же, у ClassList есть свойство length, которое возвращает количество классов у элемента.
				В Firefox 25- в методах add, remove и toggle возможно указать только один аргумент. 
			</p>
		</div>
		<div class="pair">
			<p class="question">51.Какие методы создают новый элемент, текстовую ноду? А какие удаляют?</p>
			<p class="answer">
				Для создания элементов используются следующие методы:
				метод document.createElement('tag') - используется для создания элементной ноды (т.е. создает новый элемент с указанным тегом); метод document.createTextNode('text') - используется для создания текстовой ноды (т.е. создает текстовый узел с данным текстом). <br>
				Для удаления сначала находим элемент с помощью document.querySelector(''), затем есть два метода для удаления узла: первый - метод parentElem.removeChild(elem), удаляет elem из списка детей parentElem. Можно использовать метод element.remove() (удаляет элемент напрямую, не требуя ссылки на родителя), который работает аналогично, но воспринимается легче; второй - метод parentElem.replaceChild(newElem, elem), среди детей parentElem удаляет elem и вставляет на его место newElem. Оба этих метода возвращают удаленный узел, то есть elem. Если нужно, его можно вставить в другое место DOM тут же или в будущем. Если нужно переместить элемент на новое место – не нужно его удалять со старого. Все методы вставки автоматически удаляют вставляемый элемент со старого места.
			</p>
		</div>
		<div class="pair">
			<p class="question">52.Как работает метод Element.matches()?</p>
			<p class="answer">
				Метод Element.matches(css) ничего не ищет, а проверяет, удовлетворяет ли Element указанному селектору css. Он возвращает true либо false. И бывает очень полезен при переборе элементов и в связке с matchMedia(). Не поддерживается в IE8-. window.matchMedia(query: string) - принимает в качестве аргумента @media-выражение и возвращает true или false в зависимости от его истинности. <br>
				Похожий метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск. Иначе говоря, метод closest бежит от текущего элемента вверх по цепочке родителей и проверяет, подходит ли элемент под указанный CSS-селектор. Если подходит – останавливается и возвращает его. Он самый новый из методов, поэтому старые браузеры его слабо поддерживают.
			</p>
		</div>
		<div class="pair">
			<p class="question">53.Зачем нужна библиотека Modernizr?</p>
			<p class="answer">
				Modernizr — это JavaScript-библиотека, которая узнаёт, что из HTML5 и CSS3 умеет браузер пользователя. Определяя возможности браузера, разработчик может сделать откат некоторых функций для старых версий браузеров. Создатели Modernizr называют такую проверку feature detection, и это гораздо эффективнее, чем просто определить браузер, его версию и ОС. Modernizr используют в довольно крупных компаниях: twitter, Google, Microsoft.
			</p>
		</div>
		<div class="pair">
			<p class="question">54.Чем отличаются Node.appendChild(), Node.insertBefore() и Element.insertAdjacentHTML()?</p>
			<p class="answer">
				Чтобы DOM-узел был показан на странице, его необходимо вставить в document. Для вставки внутрь некого parentElem есть следующие методы: parentElem.appendChild(elem) - добавляет elem в конец дочерних элементов parentElem; parentElem.insertBefore(elem, nextSibling) - вставляет elem в коллекцию детей parentElem, перед элементом nextSibling. Для вставки элемента в начало достаточно указать, что вставлять будем перед первым потомком. Все методы вставки возвращают вставленный узел. <br>
				Обычные методы вставки работают с одним узлом. Но есть и способы вставлять множество узлов одновременно. Метод insertAdjacentHTML позволяет вставлять произвольный HTML в любое место документа, в том числе и между узлами. Синтаксис: Elem.insertAdjacentHTML(where, html). html - строка HTML, которую нужно вставить; where - куда по отношению к elem вставлять строку. Всего четыре варианта: beforeBegin – перед elem; afterBegin – внутрь elem, в самое начало; beforeEnd – внутрь elem, в конец; afterEnd – после elem. <br>
				У этого метода есть «близнецы-братья»: elem.insertAdjacentElement(where, newElem) – вставляет в произвольное место не строку HTML, а элемент newElem; elem.insertAdjacentText(where, text) – создаёт текстовый узел из строки text и вставляет его в указанное место относительно elem. Синтаксис этих методов, за исключением последнего параметра, полностью совпадает с insertAdjacentHTML.
			</p>
		</div>
		<div class="pair">
			<p class="question">55.Что находится в свойстве Element.innerHTML? А Element.outerHTML? Ответь, чем отличаются два следующих типа вставки:</p>
			<p class="answer">
				Свойство Element.innerHTML (свойство innerHTML есть только у узлов элементов, а содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство data) позволяет получить HTML-содержимое элемента в виде строки. В innerHTML можно и читать и писать. Значение, возвращаемое innerHTML – всегда валидный HTML-код. При записи можно попробовать записать что угодно, но браузер исправит ошибки. Свойство innerHTML – одно из самых часто используемых. В Internet Explorer версии 9 и ранее, innerHTML доступно только для чтения для элементов COL, COLGROUP, FRAMESET, HEAD, HTML, STYLE, TABLE, TBODY, TFOOT, THEAD, TITLE, TR. В частности, в IE9- запрещена запись в innerHTML для любых табличных элементов, кроме ячеек (TD/TH). Синтаксически, можно добавить текст к innerHTML через '+='. На практике этим следует пользоваться с большой осторожностью, так как фактически происходит не добавление, а перезапись. Если в innerHTML есть тег script – он не будет выполнен. Если в начале innerHTML находятся стили &lt;style&gt;, то старый IE проигнорирует их. То есть, иными словами, они не применятся.<br>
				Свойство outerHTML содержит HTML элемента целиком. Изменить outerHTML элемента невозможно. Технически свойство outerHTML доступно на запись. Но при этом элемент не меняется, а заменяется на новый, который тут же создаётся из нового outerHTML. При этом переменная, в которой изначально был старый элемент, и в которой мы «перезаписали» outerHTML, остаётся со старым элементом. Это легко может привести к ошибкам. Записать новый HTML в outerHTML можно, но нужно понимать, что это никакое не изменение свойств узла, а создание нового. Новосозданный узел не доступен сразу в переменной, хотя его, конечно, можно получить из DOM.<br>
				(1) В этом случае el.innerHTML вставит HTML-код, который выделит жирным слово "Alert!"<br>
				(2) А в этом случае из-за того, что текст сообщения в el.innerHTML дополнительно обернут в текстовый узел оно вставится именно как текст, без HTML-обработки.<br>
			</p>
		</div>
	</div>
</body>
</html>