<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Answers</title>
	<link rel="stylesheet" href="css/style.min.css">
</head>
<body>
	<div class="faq">
		<div class="pair variables">
			<p class="question">1.Что такое EcmaScript?</p>
			<p class="answer disabled">
				EcmaScript содержит правила, сведения и рекомендации, которые должны соблюдаться скриптовым языком, чтобы он считался совместимым с EcmaScript. EcmaScript - это стандарт языка JavaScript. То есть это спецификация на которой основан JavaScript. А уже из документации JavaScript можно узнать как использовать скриптовый язык.
			</p>
		</div>
		<div class="pair variables">
			<p class="question">2.Для чего используются и чем отличаются атрибуты async и defer?</p>
			<p class="answer disabled">
				async и defer - это атрибуты тега script, для которых не указываются значения. Оба они используются для примитивной регулировки загрузки скриптов, но существуют и более продвинутые. async - загружает скрипт параллельно с загрузкой остального контента. Скрипт выполнится как только будет загружен. defer - выполняет скрипт только после полной загрузки страницы, и сохраняет очередность выполнения.
			</p>
		</div>
		<div class="pair variables">
			<p class="question">3.Почему предпочтительнее подключать скрипты перед &lt;/body&gt;, а не в &lt;head&gt;...&lt;/head&gt;?</p>
			<p class="answer disabled">
				Предпочтительнее подключать скрипты перед &lt;/body&gt;, так как скрипты начнут грузится после загрузки основного контента. Если же подключить скрипт в &lt;head&gt;...&lt;/head&gt;, то сначала будут грузиться все скрипты и только потом остальной контент. В &lt;head&gt;...&lt;/head&gt; подключается тот скрипт, который важен для работы всех скриптов, а перед &lt;/body&gt; - для быстрой загрузки страницы в браузере. Очередность подключения тоже важна.
			</p>
		</div>
		<div class="pair variables">
			<p class="question">4.Какие основные отличия интерпретируемого языка программирования от компилируемого?</p>
			<p class="answer disabled">
				Для использования компилируемых языков (C, C++, Go, Haskell, Rust) необходим компилятор, который переведет программу в понятный для машины код и только после этого код будет исполнен в операционной системе. Поскольку они конвертируются в машинный код, они работают гораздо быстрее и эффективнее, чем интерпретируемые. Но недостатком является то, что для тестирования любого изменения программу нужно заново компилировать, и такие языки платформо-зависимые (поскольку машинный код зависит от машины, на которой компилируется и исполняется программа). Интерпретируемые (JavaScript, PHP, Perl, Ruby, Python) же языки не нуждаются в переводе, нужна только программа-интерпретатор, которая исполнит код построчно вместо операционной системы. Плюсы их использования: независимость от платформы, рефлексия, динамическая типизация, меньший размер исполняемых файлов, динамические области видимости. Основным недостатком интерпретируемых языков является их невысокая скорость исполнения. Многие языки программирования имеют как компилируемую, так и интерпретируемую версии.
			</p>
		</div>
		<div class="pair variables">
			<p class="question">5.Что такое языки высокого и низкого уровня? Какие ты знаешь?</p>
			<p class="answer disabled">
				Языки программирования низкого уровня - это те, которые имеют прямой доступ к памяти и регистрам, и позволяют задавать машинные команды в понятном для человека виде. Для преобразования их в двоичный код были созданы специальные программы — трансляторы (компиляторы и интерпретаторы). Языки низкого уровня ориентированы на конкретный тип процессора и учитывают его особенности, поэтому для переноса программы на другую аппаратную платформу её нужно почти полностью переписать. Определенные различия есть и в синтаксисе программ под разные компиляторы. Примерами таких языков программирования являются: Ассемблер, CIL, Forth. Высокоуровневый язык программирования — язык программирования, разработанный для быстроты и удобства использования программистом. Особенности конкретных компьютерных архитектур в них не учитываются, поэтому созданные приложения легко переносятся с компьютера на компьютер. В большинстве случаев достаточно просто перекомпилировать программу под определенную компьютерную архитектурную и операционную систему. Примерами таких языков программирования являются: C++, C#, Visual Basic, Python, Perl, Fortran, Delphi и др..
			</p>
		</div>
		<div class="pair variables">
			<p class="question">6.Для чего используются переменные? Какие ключевые слова используются для создания переменных? Какие есть отличия в переопределении значений при задании переменной через let, const и var?</p>
			<p class="answer disabled">
				Переменные используются для записи значения, чтобы в дальнейшем его использовать. Ключевыми словами для создания переменных являются var, let и const. var - устаревший способ, так как переменную, заданную им, легко можно переопределить (изменить значение) и может возникнуть путаница. Переменную заданную с помощью const нельзя переопределить. А переменную заданную через let нельзя прямо переопределить (для этого нужно записать название и значение переменной без ключевого слова).
			</p>
		</div>
		<div class="pair variables">
			<p class="question">7.Может ли имя переменной начинаться с цифры, символов _ или $?</p>
			<p class="answer disabled">
				Имя переменной не может начинаться с цифры (цифры могут входить в его состав). Но может начинаться и состоять из символов _ или $ (другие символы использовать неправильно).
			</p>
		</div>
		<div class="pair variables">
			<p class="question">8.Какие слова запрещено использовать в названии переменной?</p>
			<p class="answer disabled">
				В названии переменной запрещено использовать слова, которые используются самим языком программирования. Например, const, let, class, return, export и другие. Существует целый список таких зарезервированных слов. В названии переменных можно использовать и русские буквы, но это не рекомендуется. Также не используется транслит!
			</p>
		</div>
		<div class="pair variables">
			<p class="question">9.Что такое camelCase и snake_case?</p>
			<p class="answer disabled">
				Переменные, состоящие из нескольких слов, пишутся с использованием записи camelCase или snake_case. При использовании записи camelCase несколько слов пишутся слитно без пробелов, при этом каждое слово внутри фразы пишется с прописной буквы (например, borderLeftWidth). Существует альтернативный стандарт, когда несколько слов пишутся через знак подчеркивания '_' - это так называемый snake_case. Преимущественно в JavaScript используется camelCase.
			</p>
		</div>
		<div class="pair variables">
			<p class="question">10.Что такое "типы данных"? Какой оператор позволяет определить тип данных?</p>
			<p class="answer disabled">
				В программировании тип данных это множество допустимых значений, которые могут принимать данные, принадлежащие к этому типу. Чтобы иметь возможность работать с переменной, важно знать ее тип. В JavaScript существует несколько основных типов данных. Они делятся на примитивные (числа (numbers), строки (strings), логические (boolean), символ (symbol), null, udefined) и сложные (объекты (objects), массивы (arrays), функции (functions)). typeof - оператор, позволяющий определить тип данных.
			</p>
		</div>
		<div class="pair variables">
			<p class="question">11.Что такое "динамическое приведение типов данных"? Можно ли писать JavaScript со статическим приведением типов?</p>
			<p class="answer disabled">
				Динамическое приведение типов данных - это процесс преобразования значений переменной из одного типа в другой, при этом определение типа переменной происходит не во время ее объявления, а когда ей присвается конкретное значение при запуске. JavaScript - язык с динамической типизацией. Но писать JavaScript со статическим приведением типов можно. Для этого используются инструменты вроде Flow и TypeScript. Flow — это open source библиотека для статической проверки типов, которую разработала и выпустила Facebook. Она позволяет постепенно добавлять типы в код JavaScript. TypeScript - новый язык программирования со статической типизацией (указание типа переменной при её объявлении). TypeScript представляет собой надмножество, которое компилируется в JavaScript (то есть, любой код на JS является правильным с точки зрения TypeScript). Но перед его использованием нужно очень хорошо изучить полную систему типов и как наилучшим образом их выбирать в программе. Также из-за статических типов программы часто выглядят более многословными и загроможденными, соответственно на их написание тратится больше времени. Плюсами является: возможность писать меньше тестов — все параметры методов жестко описаны, и если код скомпилировался, тогда, вероятно, каждый вызов является валидным, и не требует дополнительной проверки; скорость выполнения; при некоторых дополнительных условиях, позволяет обнаруживать потенциальные ошибки уже на этапе компиляции.
			</p>
		</div>
		<div class="pair variables">
			<p class="question">12.Как привести строчное значение "10" к числу? Назовите два способа.</p>
			<p class="answer disabled">
				Для преобразования строчного значения "10" к числу в явном виде можно вызвать Number('10'), либо, что короче, поставить перед выражением унарный плюс '+': +'10'.
			</p>
		</div>
		<div class="pair variables">
			<p class="question">13.Чем отличаются операторы "==" и "==="?</p>
			<p class="answer disabled"
			>== это оператор не строгого сравнения, а === оператор строгого. Оператор строгого сравнения учитывает не только значение переменной, но и тип данных (то есть, если значение совпадает, а тип данных нет, то будет считаться, что равенства нет).
		</p>
		</div>
		<div class="pair variables">
			<p class="question">14.Какие преимущества дают обратные кавычки (`) при указании строки?</p>
			<p class="answer disabled">
				Обратные кавычки дают возможность использовать интерполяцию. Интерполяция позволяет использовать переменные или выражения в строке и легко переносить строку.
			</p>
		</div>
		<div class="pair loops">
			<p class="question">15.Что такое "алгоритм"? Какие ты знаешь типы алгоритмов?</p>
			<p class="answer disabled">
				Алгоритм – это набор инструкций, описывающих порядок действий исполнителя для достижения некоторого результата. Существуют такие типы алгоритмов: линейный (состоит из команд, выполняемых последовательно во времени друг за другом), разветвленный (условный - содержит хотя бы одно условие, в результате которого может осуществляться разделение на несколько альтернативных ветвей алгоритма), циклический (предусматривает многократное повторение одного и того же действия над новыми исходными данными).
			</p>
		</div>
		<div class="pair loops">
			<p class="question">16.Зачем нужны циклы? Какие виды циклов ты знаешь? В чем их основные отличия?</p>
			<p class="answer disabled">
				Циклы используются для многократного повторения одного участка кода (выполнения повторяющихся вычислений). Они оптимизируют процесс написания кода. Существуют такие виды циклов: while, do…while (редко используются, т.к. считается, что они сложнее воспринимаются визуально), for (используются чаще всего), for…in, бесконечный цикл и вложенный цикл. Цикл while проверяет условие, и если оно приравнивается к true, то тело цикла выполняется. Цикл do…while сначала выполняет тело, а уже потом проверяет соответствие условию. Цикл for проверяет условие перед каждой итерацией, пока не произойдет какое-либо специальное событие завершения цикла. Цикл for…in проходит через перечисляемы свойства объекта. Он пройдет по каждому отдельному элементу.
			</p>
		</div>
		<div class="pair loops">
			<p class="question">17.Что делают операторы ++i и i++ и в чем их отличие?</p>
			<p class="answer disabled">
				Операторы ++i и i++ (более короткая запись для i = i + 1) – это инкремент, который используется для увеличения числа на 1. Инкремент можно применить только к переменной и использовать для любых выражений! ++i – его префиксная форма, а i++ - постфиксная. Отличаются они тем, что постфиксная форма возвращает старое значение (до увеличения на 1), а префиксная форма сразу возвращает увеличенное значение. Если результат оператора не используется, а нужно только увеличить переменную – без разницы, какую форму использовать. Эта разница видна только если результат оператора сразу используется. Тоже самое для декремента (--i, i--), который используется для уменьшения числа на 1.
			</p>
		</div>
		<div class="pair loops">
			<p class="question">18.Что такое "итерация"?</p>
			<p class="answer disabled">
				Итерация – это каждое повторение цикла.
			</p>
		</div>
		<div class="pair loops">
			<p class="question">19.Как называются и чем отличаются операторы || и &&?</p>
			<p class="answer disabled">
				|| и && - это логические операторы, но в JavaScript могут применяться к значениям любого типа и возвращают также значения любого типа. || - оператор "ИЛИ", && - оператор "И". Оператор || вычисляет операнды слева направо до первого "истинного" (true) и возвращает его ("короткий цикл вычисления"), а если все ложные (false) – то последнее значение. Причём, не преобразованное к логическому типу. Обычно оператор || используется в if, чтобы проверить, выполняется ли хотя бы одно из условий. Оператор && вычисляет операнды слева направо до первого «ложного» (false) и возвращает его, а если все истинные (true) – то последнее значение. Как и в ИЛИ, в И допустимы любые значения. То есть к операторам || и && применяется принцип "короткого цикла вычислений", но немного отличающийся.
			</p>
		</div>
		<div class="pair loops">
			<p class="question">20.Для чего используется break? Почему в конструкции switch нужно использовать break для каждого case?</p>
			<p class="answer disabled">
				Директива break используется для выхода из цикла. Если не указан break после каждого case, то выполнение цикла пойдет ниже по следующим case, при этом остальные проверки игнорируются.
			</p>
		</div>
		<div class="pair loops">
			<p class="question">21.Почему при выполнении указанного кода возникают ошибки?</p>
			<p class="answer disabled">
				(1) Это бесконечный цикл. Чтобы избежать создания бесконечного цикла, нужно убедиться, что заданное условие в какой-то момент вернёт false. Заданное условие никогда не вернет false, потому что переменная i всегда будет равна 0 и соответственно меньше 10.<br>
				(2) Лишняя точка с запятой (;) перед телом цикла (перед фигурной скобкой). Пропущено ключевое слово let перед объявлением переменной.<br>
				(3) Не указан break после каждого условия, то есть цикл не будет останавливаться на правильном варианте а будет выполняться до конца, при этом остальные проверки игнорируются.<br>
				(4) Вводимое пользователем число считается строкой. Нужно чтобы переменная считывалась как числовая, а не строчная. Это можно исправить, добавив унарный "+" перед prompt.<br>
			</p>
		</div>
		<div class="pair functions">
			<p class="question">22.Зачем нужны функции?</p>
			<p class="answer disabled">
				Функции нужны для повторения одного и того же кода в разных частях программы, чтобы не писать его многократно. Функция должна делать только то, что явно подразумевается её названием. И это должно быть одно действие.
			</p>
		</div>
		<div class="pair functions">
			<p class="question">23.Сколько параметров можно передать функции?</p>
			<p class="answer disabled">
				При вызове функции ей можно передать данные, которые та использует по своему усмотрению. Параметры копируются в локальные переменные функции. Параметров можно передавать больше или меньше, чем необходимо. То есть функцию можно вызвать с любым количеством параметров. Не будет никакой ошибки. Если параметр не передан при вызове – он считается равным undefined.
			</p>
		</div>
		<div class="pair functions">
			<p class="question">24.Что случится, если передать в функцию меньше параметров, чем нужно? А если больше? Объясни на примере функции add(a, b).</p>
			<p class="answer disabled">
				Параметры функции – такие же переменные, но их начальные значения задаются при вызове функции, а не в её коде. Если не передать в функцию параметр a или b, то непереданные будут считаться равными undefined. А если передать в функцию add больше параметров чем 2 ошибки не произойдет. Но, чтобы получить такие «лишние» аргументы, нужно будет прочитать их из специального объекта arguments. Он содержит список аргументов по номерам: arguments[0], arguments[1]…, а также свойство length. Все параметры находятся в arguments, даже если они есть в списке. arguments – это не массив Array. В действительности, это обычный объект, просто ключи числовые и есть length. На этом сходство заканчивается. Никаких особых методов у него нет, и методы массивов он тоже не поддерживает. В старом стандарте JavaScript псевдо-массив arguments и переменные-параметры ссылаются на одни и те же значения. То есть в результате изменения arguments влияют на параметры и наоборот.В современной редакции стандарта это поведение изменено. Аргументы отделены от локальных переменных.
			</p>
		</div>
		<div class="pair functions">
			<p class="question">25.Возможно ли для параметра указать значение по умолчанию? Назови два способа?</p>
			<p class="answer disabled">
				Для параметра функции можно указать значение по умолчанию. Для этого используется два способа. Первый способ: проверть с помощью оператора if равен ли аргумент undefined, и если да – то записать в него значение по умолчанию. Второй способ: использовать оператор || (запись выглядит так: text = text || 'текст не передан';). То есть считается, что аргумент отсутствует, если передана пустая строка, 0, или вообще любое значение, которое в логическом контексте является false. Также можно указывать параметры по умолчанию через "=" в списке параметров в скобках после имени функции. Параметр по умолчанию используется при отсутствующем аргументе или равном undefined. При передаче любого значения, кроме undefined, включая пустую строку, ноль или null, параметр считается переданным, и значение по умолчанию не используется. Параметры по умолчанию могут быть не только значениями, но и выражениями.
			</p>
		</div>
		<div class="pair functions">
			<p class="question">26.Что такое область видимости?</p>
			<p class="answer disabled">
				Переменные объявленные внутри функции нельзя вызвать вне. То есть внутри функции создается локальная область видимости. Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных. При объявлении переменной в таких блоках, она всё равно будет видна во всей функции. Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию. Переменные, объявленные на уровне всего скрипта, называют «глобальными переменными». Функция может обратиться к таким внешним переменным. Доступ возможен не только на чтение, но и на запись. При этом, так как переменная внешняя, то изменения будут видны и снаружи функции.
			</p>
		</div>
		<div class="pair functions">
			<p class="question">27.Чем отличается Function Declaration от Function Expression?</p>
			<p class="answer disabled">
				 Function Declaration от Function Expression это синтаксисы для объявления функции. Функции, созданные с помощью Function Declaration создаются интерпретатором до выполнения кода, поэтому их можно вызвать раньше объявления (такое поведение называют термином "поднятие" (hoisting)). Так же их не используют для условного объявление в if. А функции, созданные с помощью Function Expression нельзя вызвать до оглашения, потому что интерпретатор создает их, когда доходит до строчки кода в которой записана функция. И они работают в if.
			</p>
		</div>
		<div class="pair functions">
			<p class="question">28.Что такое замыкание?</p>
			<p class="answer disabled">
				Замыкание (closure) – это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. Но в JavaScript есть небольшая терминологическая особенность. Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.<br>
				«Понимать замыкания» в JavaScript означает понимать следующие следующее. Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window. При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана. При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения». Замыкания полезны тем, что позволяют связать данные (лексическое окружение) с функцией, которая работает с этими данными.
			</p>
		</div>
		<div class="pair functions">
			<p class="question">29.Далее указан полный код программы. Что мы увидим в консоли браузера? Почему? Что может вернуть функция makeNoize? Почему при выполнении указанного кода возникают ошибки?</p>
			<p class="answer disabled">
				Данный код вернет в консоль undefined. Потому что функция еще не была вызвана. Функция makeNoize может вернуть любое зачение (строку или число) если вызвать ее makeNoize() и записать в скобках это значение.
				(1) Переменные объявлены внутри функции, то есть их область видимости ограничена функцией. И вызванный console.log просто не находит их. Поэтому console.log должен быть вызван внутри функции. Его так же можно заменить на директиву return. И при вызове функции появится то же сообщение.<br>
				(2) Переменную number нельзя переопределить, так как она объявлена с помощью ключевого слова const. Нужно использовать для объявления переменной number ключевое слово let, которое дает возмозможность переопределить переменную, записав название и значение переменной без ключевого слова.<br>
				(3) Первая функция создана с помощью Function Expression, то есть ее нельзя вызвать до объявления. А вторая функция создана с помощью Function Declaration, то есть создается интерпретатором до выполнения кода, поэтому ее можно вызвать раньше объявления.<br>
				(4) console.log, вызванный после функции, не найдет переменную surname. Из-за того, что она объявлена в функции у которой своя локальная область видимости.<br>
			</p>
		</div>
		<div class="pair objects">
			<p class="question">30.Как можно добавить свойства или методы у объекта? Как можно удалить свойство или метод?</p>
			<p class="answer disabled">
				Существует три способа добавления свойств у объекта. Первый – перечислить «свойство: значение» в теле объекта, через запятую каждая пара. Второй – через точку указать имяОбъекта.новоеСвойство и приравнять ему значение. Третий – определить новые свойства как отдельные переменные со значением, и потом указать имена этих переменных в теле объекта через запятую. Для удаления свойства или объекта используем оператор delete потом указываем имяОбъекта.имяСвойства/имяМетода.
			</p>
		</div>
		<div class="pair objects">
			<p class="question">31.Как можно перебирать свойства объектов?</p>
			<p class="answer disabled">
				Начиная с ECMAScript 5 свойства объектов можно перебрать с помощью: цикла for…in, метода Object.keys(o), метода Object.getOwnPropertyNames(o).<br>
				Цикл for…in (for (key in obj) { } При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key и вызвано тело цикла.) перебирает все перечисляемые свойства объекта и его цепочку прототипов. Вспомогательную переменную key можно объявить прямо в цикле.<br>
				Метод Object.keys(o) возвращает массив со всеми собственными (те, что в цепочке прототипов, не войдут в массив) именами перечисляемых свойств объекта «о».<br>
				Метод Object.getOwnPropertyNames(o) возвращает массив содержащий все имена своих свойств (перечисляемых и не перечисляемых) объекта «о».
			</p>
		</div>
		<div class="pair objects">
			<p class="question">32.Что такое прототипное наследование?</p>
			<p class="answer disabled">
				В JavaScript есть встроенное «наследование» между объектами при помощи специального свойства __proto__. Это скрытое системное свойство, и не во всех реализациях языка оно доступно пользователю. При установке свойства rabbit.__proto__ = animal говорят, что объект animal будет «прототипом» rabbit. При чтении свойства из объекта, если его в нём нет, оно ищется в __proto__. Прототип задействуется только при чтении свойства. Операции присвоения obj.prop = или удаления delete obj.prop совершаются всегда над самим объектом obj. Несколько прототипов одному объекту присвоить нельзя, но можно организовать объекты в цепочку (prototype chain), когда один объект ссылается на другой при помощи __proto__, тот ссылается на третий, и так далее.<br>
				Так как свойство __proto__ является скрытым, и не описано в спецификации языка, то использование его в явном виде некорректно. Однако в последней (действующей) спецификации ECMA Script 5 наконец-то появились два метода, позволяющие манипулировать свойством __proto__, это Object.create, Object.setPrototypeOf(obj, proto) и Object.getPrototypeOf.<br>
				Object.create(proto, descriptors) - создаёт пустой объект с __proto__, равным первому аргументу, второй необязательный аргумент может содержать дескрипторы свойств.<br>
				Метод Object.setPrototypeOf(obj, prototype) устанавливает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта в другой объект или null. obj  - Объект, которому устанавливается прототип. prototype - Новый прототип объекта (объект или null).<br>
				Метод Object.getPrototypeOf(obj) возвращает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта. Obj - Объект, чей прототип будет возвращён. В ES5, если параметр obj не является объектом, будет выброшено исключение TypeError. В ES6, параметр будет приведён к объекту Object.<br>
				Изменение прототипа [[Prototype]] объекта является, по самой природе оптимизации доступа к свойствам в современных движках JavaScript, очень медленной операцией, это справедливо для любого браузера и движка JavaScript. Изменение прототипов очень тонко и обширно влияет на производительность, причём это влияние не ограничивается просто временем, проведённым внутри метода Object.setPrototypeOf(), оно может распространяться на любой код, который имеет доступ к любомуобъекту, чей прототип [[Prototype]] был изменён. Если вы заботитесь о производительности, вы никогда не должны изменять прототип [[Prototype]] объекта. Вместо этого создайте объект с нужным прототипом [[Prototype]], с помощью метода Object.create().
			</p>
		</div>
		<div class="pair objects">
			<p class="question">33.Как можно обратиться к свойству с именем my-SoMe-PROPERTY+name?</p>
			<p class="answer disabled">
				Имена свойств объекта могут быть строками JavaScript, или тем, что может быть сконвертировано в строку, включая пустую строку. Как бы то ни было, доступ к любому имени свойства, которое содержит невалидный JavaScript идентификатор (например, имя свойства содержит в себе пробел и тире или начинается с цифры), может быть получен с использованием квадратных скобок. Этот способ записи также полезен, когда имена свойств должны быть динамически определены (когда имя свойства не определено до момента исполнения).<br>
				имяОбъекта[“my-SoMe-PROPERTY+name”]<br>
				Все ключи с квадратными скобками преобразуются в тип String, поскольку объекты в JavaScript могут иметь в качестве ключа только тип String. 
			</p>
		</div>
		<div class="pair objects">
			<p class="question">34.Объясни, что такое деструктуризация.</p>
			<p class="answer disabled">
				Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части. <br>
				Синтаксис:<br>
				let {prop : varName = default, ...} = object<br>
				Здесь двоеточие : задаёт отображение свойства prop в переменную varName, а равенство =default задаёт выражение, которое будет использовано, если значение отсутствует (не указано или undefined).<br>Для массивов имеет значение порядок, поэтому нельзя использовать :, но значение по умолчанию – можно:<br>
				let [var1 = default, var2, ...rest] = array<br>
				Объявление переменной в начале конструкции не обязательно. Можно использовать и существующие переменные. Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки. Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.
			</p>
		</div>
		<div class="pair objects">
			<p class="question">35.Почему при выполнении указанного кода возникают ошибки?</p>
			<p class="answer disabled">
				Пропущен контекстный вызов (this) для доступа из метода к свойству age, принадлежащего текущему объекту  cat. При вызове метода не объявлено имя объекта, в котором он указан (cat.doMeow()).
			</p>
		</div>
		<div class="pair arrays">
			<p class="question">36.Что такое массив?</p>
			<p class="answer disabled">
				Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией. Они обычно используются для хранения упорядоченных коллекций данных, например – списка товаров на странице, студентов в группе и т.п.
			</p>
		</div>
		<div class="pair arrays">
			<p class="question">37.Чем массив отличается от объекта?</p>
			<p class="answer disabled">
				Для объекта последовательность информации не важна, этот тип данных больше всего подходит для структурирования информации по названию данных. Объекты хранят информацию в виде пары ключ-значение. Поэтому когда легче получить доступ к данным на основании их имён (ключа), то необходимо хранить эти данные в виде объекта. А массив используется тогда, когда последовательность информации имеет большое значение. Когда нужно перебрать массив, то используется номер для каждого элемента массива. Массивы — это структуры данных, где нумерация начинается с нуля. То есть к первому элементу обращаемся так: имяМассива[0]. <br>
				При использовании оператора delete для удаления элемента из массива, на месте элемента остается дырка. В случае с объектом пустое место не остается. Так что для удаления элемента массива лучше всего использовать методы pop (для последнего элемента), shift (для первого элемента) или splice (для значения отличного от первого или последнего. Синтаксис: arrayName.splice(начальный индекс, сколько удалить, элементы, которые будут подставлены в массив)).
			</p>
		</div>
		<div class="pair arrays">
			<p class="question">38.Что такое callback?</p>
			<p class="answer disabled">
				callback - это функция обратного вызова, которая передается в качестве аргумента другой функции и выполняется после выполнения основного кода.
			</p>
		</div>
		<div class="pair arrays">
			<p class="question">39.Чем отличаются методы Array.of и Array.from?</p>
			<p class="answer disabled">
				Методы Array.of и Array.from преобразуют полученные элементы в массив. Они отличаются тем, что Array.of() принимает неограниченное число аргументов и превращает их все в массив, Array.from() принимает callback в качестве второго аргумента.
			</p>
		</div>
		<div class="pair arrays">
			<p class="question">40.Как можно узнать длину массива?</p>
			<p class="answer disabled">
				Длинну массива можно узнать с помощью свойства length. Длинна length - не количество элементов массива, а индекс последнего элемента + 1. Это свойство также позволяет укорачивать массив: arrayName.length = колличество оставшихся элементов. Причем этот процесс необратимый, то есть даже если потом вернуть length обратно – значения не восстановятся.
			</p>
		</div>
		<div class="pair arrays">
			<p class="question">41.Почему методы pop/push быстрее, чем shift/unshift?</p>
			<p class="answer disabled">
				Метод push добавляет новый элемент в конец массива, а unshift - в начало массива. Метод pop удаляет последний элемент и возвращает его, а shift - первый и возвращает его (это означает, что можно "поймать" удаленный элемент и поместить в переменную.). Методы pop/push выполняются быстрее, чем shift/unshift, потому что для добавления или удаления элемента сначала массива нужно еще и переместить элементы на их новые индексы, и изменить значение length. Чем больше элементов в массиве, тем дольше их перемещать, это много операций с памятью. А перемещать при pop не требуется, так как прочие элементы после этой операции остаются на тех же индексах и уменьшается значение length. Аналогично работает push.
			</p>
		</div>
		<div class="pair arrays">
			<p class="question">42.Дополни следующий код. 1) Как обратиться к свойству name? 2) Как задать свойство age равное 41?</p>
			<p class="answer disabled">
				(1) user[0].name;<br>
				(2) user[0].age = 41;<br> 
			</p>
		</div>
		<div class="pair dom">
			<p class="question">43.Что такое DOM?</p>
			<p class="answer disabled">
				Сам по себе язык JavaScript не предусматривает работы с браузером. Он вообще не знает про HTML. Но позволяет легко расширять себя новыми функциями и объектами.
				DOM (Document Object Model) - это представление HTML-документа в виде дерева объектов, доступное для изменения через JavaScript. Из DOM легко можно управлять содержимым, стилями, значениями атрибутов. У элементов DOM есть свойства и методы, которые позволяют изменять их. Кстати, DOM-модель (внутреннее представление HTML-страницы в виде дерева) используется не только в JavaScript, это известный способ представления XML-документов. В мире DOM в качестве значения, обозначающего «нет такого элемента» или «узел не найден», используется не undefined, а null.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">44.Что такое узел (нода)? Какие существуют ноды?</p>
			<p class="answer disabled">
				Каждый HTML-тег образует узел (ноду) дерева с типом «элемент». Вложенные в него теги становятся дочерними узлами. Для представления текста создаются узлы с типом «текст». Всего различают 12 типов узлов. Самыми основными являются четыре: документ (точка входа в DOM), узлы-элементы (element node), текстовые узлы (text node) и комментарии (иногда в них можно включить информацию, которая не будет показана, но доступна из JS). Теги образуют узлы-элементы (element node). Естественным образом одни узлы вложены в другие. Структура дерева образована исключительно за счет них. Текст внутри элементов образует текстовые узлы (text node). Текстовый узел содержит исключительно строку текста и не может иметь потомков, то есть он всегда на самом нижнем уровне. Пробелы и переводы строки – это тоже текст, полноправные символы, которые учитываются в DOM. Но на самом верхнем уровне из этого правила есть исключения: пробелы до &lt;head&gt; по стандарту игнорируются, а любое содержимое после &lt;/body&gt; не создаёт узла, браузер переносит его внутрь, в конец body.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">45.Какие есть способы поиска элементов на странице?</p>
			<p class="answer disabled">
				Существует поиск элементов по классу (document.getElementsByClassName()), по тегу (document.getElementsByTagName()) или идентификатору (document.getElementById()). document.getElementsByClassName(classNames: DOMString) - принимает в качестве аргумента любой класс и возвращает коллекцию (похожа на массив, поскольку имеет индексы и к ним можно обратиться, как к обычному массиву. Но отсутствуют методы массивов и для перебора используют цикл for). document.getElementsByTagName(classNames: DOMString) - принимает в качестве аргумента любой тег и возвращает коллекцию. Можно получить всех потомков, передав звездочку '*' вместо тега. document.getElementById(classNames: DOMString) - принимает в качестве аргумента идентификатор и возвращает элемент (ноду). <br>
				Более продвинутыми методами являются document.querySelectorAll() и document.querySelector(). document.querySelectorAll(selectors: DOMString) - принимает в качестве аргумента любой CSS-селектор и возвращает NodeList (в отличии от коллекции, имеет в прототипе некоторые удобные методы). document.querySelector(selectors: DOMString) - принимает в качестве аргумента любой CSS-селектор и возвращает первый найденный на странице элемент. И является аналогом document.querySelectorAll('.someclass')[0], но работает быстрее. При использовании этих двух методов можно перебирать полученный псевдомассив при помощи forEach. Псевдо-классы в CSS-селекторе, в частности :hover и :active, также поддерживаются. Например, document.querySelectorAll(':hover') вернёт список, в порядке вложенности, из текущих элементов под курсором мыши.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">46.Что возвращает метод document.getElementById()? А метод document.querySelectorAll()?</p>
			<p class="answer disabled">
				Метод document.getElementById(elementId: DOMString) принимает в качестве аргумента идентификатор и возвращает элемент (ноду). И существует только в контексте document. А метод document.querySelectorAll(selectors: DOMString) принимает в качестве аргумента любой CSS-селектор и возвращает NodeList. Т.е. возвращает все элементы внутри document, удовлетворяющие CSS-селектору css. Это один из самых часто используемых и полезных методов при работе с DOM.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">47.Как изменить стили элемента? Какая существует особенность с правилам, в названии которых есть дефис (border-radius, padding-left)? Какая особенность есть со свойством float? Можно ли задать элементу сразу несколько CSS-свойств?</p>
			<p class="answer disabled">
				element.style.property - возвращает строку со значением указанного свойства. Свойство style содержит лишь тот стиль, который указан в атрибуте элемента, без учёта каскада CSS. Свойство currentStyle(IE8-) и метод getComputedStyle (IE9+, стандарт) позволяют получить реальное, применённое сейчас к элементу свойство стиля с учётом CSS-каскада и браузерных стилей по умолчанию. При этом currentStyle возвращает значение из CSS, до окончательных вычислений, а getComputedStyle – окончательное, непосредственно применённое к элементу (как правило).<br> 
				А element.style.property = 'value' - задает свойству указанное значение. К правилам, в названии которых есть дефис (border-radius, padding-left), обращаются, используя camelCase (т.е. borderRadius, paddingLeft и т.д.). Специфические свойства браузеров, типа -moz-border-radius, -webkit-border-radius, записываются следующим способом: button.style.MozBorderRadius. То есть, каждый дефис даёт большую букву.<br>
				Исключением является свойство float. В старом стандарте JavaScript слово "float" было зарезервировано и недоступно для использования в качестве свойства объекта. Поэтому используется не elem.style.float, а elem.style.cssFloat.<br>	
				element.style.cssText = `color: #111;` - позволяет указать сразу несколько CSS-свойств для элемента. При установке style.cssText все предыдущие свойства style удаляются.<br>
				Об этом иногда забывают, но в style так же, как и в CSS, нужно указывать единицы измерения, например px. Чтобы сбросить поставленный стиль, присваивают в style пустую строку: elem.style.width="". При сбросе свойства style стиль будет взят из CSS. В большинстве случаев внешний вид элементов задаётся классами. А JavaScript добавляет или удаляет их. Такой код красив и гибок, дизайн можно легко изменять. Свойство style нужно использовать лишь там, где классы не подходят, например если точное значение цвета/отступа/высоты вычисляется в JavaScript.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">48.Чем отличается HTMLCollection / NodeList от массива?</p>
			<p class="answer disabled">
				HTMLCollection (это список узлов в порядке упоминания в документе) похожа на массив, поскольку имеет индексы и к ним можно обратиться, как к обычному массиву. Но у нее отсутствуют методы массивов (такие как forEach, map, push, pop и др.) и для перебора используют цикл for. Для перебора нельзя использовать for...in, который кроме индексов будет выводить еще и лишнюю информацию (свойство length (в коллекции оно enumerable), а также функцию item(n) – она никогда не используется, возвращает n-й элемент коллекции, проще обратиться по индексу [n]). HTMLCollection, хранящая элементы DOM, является динамической. Т.е. при изменении документа она моментально отражает все произведённые изменения. Коллекция HTML всегда находится в DOM, в то время как NodeList является более универсальной конструкцией, которая может или не может быть в DOM. <br>
				NodeList (это коллекция узлов, возвращаемая такими методами, как Node.childNodes и document.querySelectorAll) все же имеет в прототипе некоторые удобные методы. Поэтому при использовании querySelector() или querySelectorAll() можно перебирать полученный псевдомассив при помощи forEach. NodeList также можно конвертировать в Array при помощи Array.from(). Объекты NodeList являются динамическими или статическимы (любые изменения в DOM не отражаются на его содержании), в зависимости от способа используемого для их получения. К примеру, document.querySelectorAll возвращает статический NodeList. Но не все объекты NodeList являются статическими. Например, document.getElementByName вернет “живой” NodeList.<br>
				Когда необходимо преобразовывать NodeList в массив? Это зависит от конкретного случая. Если нужно использовать актуальную информацию об узлах в DOM все время, то должны использоваться NodeList или HTMLCollection как есть, без преобразования в массив. <br>
				Перебор коллекции методами массива все-таки возможен: <br>
				1. Применить метод массива через call/apply. <br>
				2. При помощи Array.prototype.slice сделать из коллекции массив. Обычно вызов arr.slice(a, b) делает новый массив и копирует туда элементы arr с индексами от a до b-1 включительно. Если же вызвать его без аргументов arr.slice(), то он делает новый массив и копирует туда все элементы arr. Это работает и для коллекции.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">49.Как обратиться к родителю элемента? А к потомку?</p>
			<p class="answer disabled">
				Псевдо-массив childNodes хранит все дочерние элементы, включая текстовые. Доступ к элементам слева и справа данного можно получить по ссылкам previousSibling / nextSibling. Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему элементу. Родитель доступен через parentNode. Если долго идти от одного элемента к другому, то рано или поздно дойдёшь до корня DOM, то есть до document.documentElement, а затем и document. Навигационные ссылки, описанные выше, равно касаются всех узлов в документе. В частности, в childNodes сосуществуют и текстовые узлы и узлы-элементы и узлы-комментарии, если есть. Но для большинства задач текстовые узлы не интересны. <br>
				Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element: children (только дочерние узлы-элементы, то есть соответствующие тегам); firstElementChild, lastElementChild (соответственно, первый и последний дети-элементы); previousElementSibling, nextElementSibling (соседи-элементы) и parentElement (родитель-элемент). Т.е. теперь будут выводиться не все узлы, а только узлы-элементы. В IE8- поддерживается только children. В IE8- в children присутствуют узлы-комментарии. У конкретных элементов DOM могут быть свои дополнительные ссылки для большего удобства навигации (например, у таблиц и форм).
			</p>
		</div>
		<div class="pair dom">
			<p class="question">50.Опиши, какие методы и свойства используются для работы с классами?</p>
			<p class="answer disabled">
				Самое главное различие между DOM-узлами – разные узлы являются объектами различных классов. DOM-узлы – обычные JavaScript-объекты. Их классы заданы в прототипном стиле. В этом легко убедиться, если вывести в консоли любой элемент через console.dir(elem) (выводит элемент в виде JavaScript-объекта, удобно для анализа его свойств). Или даже можно напрямую обратиться к методам, которые хранятся в Node.prototype, Element.prototype и так далее. <br>
				Свойство classList возвращает псевдомассив DOMTokenList, содержащий все классы элемента.
				У classList есть примитивная альтернатива - свойство className, которое содержит значение атрибута class элемента. ClassList является геттером. Возвращаемый им объект имеет несколько методов: <br>
				add( String [,String] ) - добавляет элементу указанные классы (синтаксис: element.classList.add()); 
				remove( String [,String] ) - удаляет у элемента указанные классы; 
				item ( Number ) - используется для получения класса по его индексу в списке, результат аналогичен вызову сlassList[Number]; 
				toggle ( String [, Boolean]) -  если класс у элемента отсутствует - добавляет, иначе - убирает. Когда вторым параметром передано false - удаляет указанный класс, а если true - добавляет. Если вторым параметром передан undefined или переменная с typeof == 'undefined', поведение будет аналогичным передаче только первого параметра при вызове toggle. 
				contains ( String ) - проверяет, есть ли данный класс у элемента (вернет true или false).
				И, конечно же, у ClassList есть свойство length, которое возвращает количество классов у элемента.
				В Firefox 25- в методах add, remove и toggle возможно указать только один аргумент. 
			</p>
		</div>
		<div class="pair dom">
			<p class="question">51.Какие методы создают новый элемент, текстовую ноду? А какие удаляют?</p>
			<p class="answer disabled">
				Для создания элементов используются следующие методы:
				метод document.createElement('tag') - используется для создания элементной ноды (т.е. создает новый элемент с указанным тегом); метод document.createTextNode('text') - используется для создания текстовой ноды (т.е. создает текстовый узел с данным текстом). <br>
				Для удаления сначала находим элемент с помощью document.querySelector(''), затем есть два метода для удаления узла: первый - метод parentElem.removeChild(elem), удаляет elem из списка детей parentElem. Можно использовать метод element.remove() (удаляет элемент напрямую, не требуя ссылки на родителя), который работает аналогично, но воспринимается легче; второй - метод parentElem.replaceChild(newElem, elem), среди детей parentElem удаляет elem и вставляет на его место newElem. Оба этих метода возвращают удаленный узел, то есть elem. Если нужно, его можно вставить в другое место DOM тут же или в будущем. Если нужно переместить элемент на новое место – не нужно его удалять со старого. Все методы вставки автоматически удаляют вставляемый элемент со старого места.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">52.Как работает метод Element.matches()?</p>
			<p class="answer disabled">
				Метод Element.matches(css) ничего не ищет, а проверяет, удовлетворяет ли Element указанному селектору css. Он возвращает true либо false. И бывает очень полезен при переборе элементов и в связке с matchMedia(). Не поддерживается в IE8-. window.matchMedia(query: string) - принимает в качестве аргумента @media-выражение и возвращает true или false в зависимости от его истинности. <br>
				Похожий метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск. Иначе говоря, метод closest бежит от текущего элемента вверх по цепочке родителей и проверяет, подходит ли элемент под указанный CSS-селектор. Если подходит – останавливается и возвращает его. Он самый новый из методов, поэтому старые браузеры его слабо поддерживают.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">53.Зачем нужна библиотека Modernizr?</p>
			<p class="answer disabled">
				Modernizr — это JavaScript-библиотека, которая узнаёт, что из HTML5 и CSS3 умеет браузер пользователя. Определяя возможности браузера, разработчик может сделать откат некоторых функций для старых версий браузеров. Создатели Modernizr называют такую проверку feature detection, и это гораздо эффективнее, чем просто определить браузер, его версию и ОС. Modernizr используют в довольно крупных компаниях: twitter, Google, Microsoft.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">54.Чем отличаются Node.appendChild(), Node.insertBefore() и Element.insertAdjacentHTML()?</p>
			<p class="answer disabled">
				Чтобы DOM-узел был показан на странице, его необходимо вставить в document. Для вставки внутрь некого parentElem есть следующие методы: parentElem.appendChild(elem) - добавляет elem в конец дочерних элементов parentElem; parentElem.insertBefore(elem, nextSibling) - вставляет elem в коллекцию детей parentElem, перед элементом nextSibling. Для вставки элемента в начало достаточно указать, что вставлять будем перед первым потомком. Все методы вставки возвращают вставленный узел. <br>
				Обычные методы вставки работают с одним узлом. Но есть и способы вставлять множество узлов одновременно. Метод insertAdjacentHTML позволяет вставлять произвольный HTML в любое место документа, в том числе и между узлами. Синтаксис: Elem.insertAdjacentHTML(where, html). html - строка HTML, которую нужно вставить; where - куда по отношению к elem вставлять строку. Всего четыре варианта: beforeBegin – перед elem; afterBegin – внутрь elem, в самое начало; beforeEnd – внутрь elem, в конец; afterEnd – после elem. <br>
				У этого метода есть «близнецы-братья»: elem.insertAdjacentElement(where, newElem) – вставляет в произвольное место не строку HTML, а элемент newElem; elem.insertAdjacentText(where, text) – создаёт текстовый узел из строки text и вставляет его в указанное место относительно elem. Синтаксис этих методов, за исключением последнего параметра, полностью совпадает с insertAdjacentHTML.
			</p>
		</div>
		<div class="pair dom">
			<p class="question">55.Что находится в свойстве Element.innerHTML? А Element.outerHTML? Ответь, чем отличаются два следующих типа вставки:</p>
			<p class="answer disabled">
				Свойство Element.innerHTML (свойство innerHTML есть только у узлов элементов, а содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство data) позволяет получить HTML-содержимое элемента в виде строки. В innerHTML можно и читать и писать. Значение, возвращаемое innerHTML – всегда валидный HTML-код. При записи можно попробовать записать что угодно, но браузер исправит ошибки. Свойство innerHTML – одно из самых часто используемых. В Internet Explorer версии 9 и ранее, innerHTML доступно только для чтения для элементов COL, COLGROUP, FRAMESET, HEAD, HTML, STYLE, TABLE, TBODY, TFOOT, THEAD, TITLE, TR. В частности, в IE9- запрещена запись в innerHTML для любых табличных элементов, кроме ячеек (TD/TH). Синтаксически, можно добавить текст к innerHTML через '+='. На практике этим следует пользоваться с большой осторожностью, так как фактически происходит не добавление, а перезапись. Если в innerHTML есть тег script – он не будет выполнен. Если в начале innerHTML находятся стили &lt;style&gt;, то старый IE проигнорирует их. То есть, иными словами, они не применятся.<br>
				Свойство outerHTML содержит HTML элемента целиком. Изменить outerHTML элемента невозможно. Технически свойство outerHTML доступно на запись. Но при этом элемент не меняется, а заменяется на новый, который тут же создаётся из нового outerHTML. При этом переменная, в которой изначально был старый элемент, и в которой мы «перезаписали» outerHTML, остаётся со старым элементом. Это легко может привести к ошибкам. Записать новый HTML в outerHTML можно, но нужно понимать, что это никакое не изменение свойств узла, а создание нового. Новосозданный узел не доступен сразу в переменной, хотя его, конечно, можно получить из DOM.<br>
				(1) В этом случае el.innerHTML вставит HTML-код, который выделит жирным слово "Alert!"<br>
				(2) А в этом случае из-за того, что текст сообщения в el.innerHTML дополнительно обернут в текстовый узел оно вставится именно как текст, без HTML-обработки.<br>
			</p>
		</div>
		<div class="pair events">
			<p class="question">56.Что такое событие? Какие бывают события?</p>
			<p class="answer disabled">
				Событие (Event) - это сигнал от браузера о том, что что-то произошло. Каждое событие представляет объект, который базируется на интерфейсе Event и может иметь дополнительные поля и/или функции, позволяющие получить дополнительную информацию о том, что случилось. События могут описывать всё, что угодного от простых действий пользователя (при использовании пользователем клавиатуры, мыши, загрузке страницы) до действий автоматизированной системы рассылки уведомлений, создаваемых моделью формирования экрана. Существует много видов событий. Некоторые стандартные события определены в официальной документации, тогда как другие события являются специфичными для конкретных браузеров. <br>
				Некоторые виды событий: 
				события мыши - click (происходит, когда кликнули на элемент левой кнопкой мыши), dblclick, mousedown (когда кнопку мыши нажали), mouseup (когда кнопку мыши отжали), mouseover (возникает, когда на элемент наводится мышь), mouseout (срабатывает, когда курсор сдвигается за границы элемента или его дочерних элементов (даже если курсор все еще находится в пределах элемента)), mouseleave (срабатывает, когда курсор мыши сдвигается за границы элемента и всех его дочерних элементов, схож с mouseout), mouseenter, mousemove (при движении мыши), contextmenu (происходит, когда кликнули на элемент правой кнопкой мыши), wheel (колесико мышки прокручивается в любом направлении);
				события клавиатуры - keydown (когда посетитель нажимает клавишу), keypress, keyup (когда посетитель отпускает клавишу); 
				события элементов управления - submit (посетитель отправил форму &lt;form&gt;), focus (посетитель фокусируется на элементе, например нажимает на &lt;input&gt;), blur (элемент потерял фокус (не происходит всплытие)), change (элемент теряет фокус, и его значение изменилось с момента получения фокуса); 
				события документа - DOMContentLoaded (когда HTML загружен и обработан, DOM документа полностью построен и доступен), load; 
				события CSS - transitionend (когда CSS-анимация завершена).
			</p>
		</div>
		<div class="pair events">
			<p class="question">57.Как можно привязывать обработчики к событию? Какие есть недостатки у разных способов привязки к событиям?</p>
			<p class="answer disabled">
				Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло. Именно благодаря обработчикам JavaScript-код может реагировать на действия посетителя. Существует три способа привязывать обработчики к событию. <br>
				1 способ - HTML атрибуты. Самый простой способ назначить обработчик - использование HTML атрибутов, которые начинаются с "on-". В кавычках указывается функция, которая выполнится тогда, когда произойдет событие. Пример: &lt;button onfocus="alert(this.innerHTML);"&gt;Button 1&lt;/button&gt;. Атрибут HTML-тега не чувствителен к регистру, поэтому ONFOCUS будет работать так же, как onFocus или onFOCUS… Но, как правило, атрибуты пишут в нижнем регистре: onfocus. Этот способ не рекомендуется использовать, поскольку смешивается HTML и JS. <br>
				2 способ - обращение к свойствам элемента. Можно назначать обработчик, используя свойство DOM-элемента on&lt;событие&gt;. Если обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство, например, onclick. Обработчик хранится именно в DOM-свойстве, а атрибут – лишь один из способов его инициализации. Но таким образом на элемент можно повесить только один обработчик. Кстати, обработчиком можно назначить и уже существующую функцию. Функция должна быть присвоена как sayThanks, а не sayThanks(). Если добавить скобки, то sayThanks() – будет уже результат выполнения функции (а так как в ней нет return, то в обработчик попадёт undefined). Нам же нужна именно функция. А вот в разметке как раз скобки нужны. Также не нужно использовать setAttribute. Такой вызов работать не будет, потому что при назначении в атрибут функция будет преобразована в строку. Регистр DOM-свойства имеет значение. При назначении через DOM нужно использовать свойство onfocus, а не ONFOCUS. <br>
				3 способ - методы addEventListener. Он является современным способом назначить обработчик, и при этом позволяет использовать сколько угодно любых обработчиков. Назначение обработчика осуществляется вызовом addEventListener с тремя аргументами: element.addEventListener(event, handler[, phase]). event - имя события, например click; handler - ссылка на функцию, которую надо поставить обработчиком; phase - необязательный аргумент, «фаза», на которой обработчик должен сработать. Последний аргумент редко нужен. Есть некоторые события, которые нельзя назначить через DOM-свойство, но можно через addEventListener. Например, таково событие transitionend, то есть окончание CSS-анимации. В большинстве браузеров оно требует назначения через addEventListener.
			</p>
		</div>
		<div class="pair events">
			<p class="question">58.Что такое "делегирование"? В чем преимущество использования делегирования?</p>
			<p class="answer disabled">
				Всплытие событий позволяет реализовать один из самых важных приёмов разработки – делегирование. Делегирование заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому – мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.
				Зачем используется: упрощает инициализацию и экономит память: не нужно вешать много обработчиков; меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики; удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML.
			</p>
		</div>
		<div class="pair events">
			<p class="question">59.Как удалить обработчик события?</p>
			<p class="answer disabled">
				Удаление обработчика осуществляется вызовом метода removeEventListener: element.removeEventListener(event, handler[, phase]). Передаются те же аргументы, что и у addEventListener, и так же можно использовать сколько угодно любых обработчиков. Для удаления нужно передать именно ту функцию-обработчик которая была назначена. Если функцию не сохранить где-либо, а просто передать в addEventListener, то потом получить её обратно, чтобы снять обработчик, будет невозможно. Нет метода, который позволяет считать обработчики событий, назначенные через addEventListener.
			</p>
		</div>
		<div class="pair events">
			<p class="question">60.Чему равен this в функции-обработчике события? Какая есть особенность у стрелочных функций и this?</p>
			<p class="answer disabled">
				Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором он сработал. Это можно использовать, чтобы получить свойства или изменить элемент. Стрелочные функции не создают собственный контекст this, а используют значение this окружающего контекста. 
			</p>
		</div>
		<div class="pair events">
			<p class="question">61.Что такое "захват" и "всплытие". Какую роль они играют?</p>
			<p class="answer disabled">
				Захват и всплытие - это фазы события. Захват (Capturing) - когда происходит событие, информация о нем спускается от корневого элемента DOM-дерева вниз, до того элемента, на котором произошло событие. Обработчики, добавленные через on...-свойство, ничего не знают о стадии захвата, а начинают работать со всплытия. Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент addEventListener: если аргумент true, то событие будет перехвачено по дороге вниз; если аргумент false, то событие будет поймано при всплытии. Один и тот же обработчик можно назначить на разные стадии. При этом номер текущей стадии он, при необходимости, может получить из свойства event.eventPhase (=1, если погружение, =3, если всплытие). Бывают события, которые можно поймать только на стадии захвата, а на стадии всплытия – нельзя. Например, таково событие фокусировки на элементе onfocus. Конечно, это большая редкость, такое исключение существует по историческим причинам.
				Всплытие (Bubbling) - информация о событиии поднимается обратно от элемента, на котором произошло событие до корневого элемента DOM-дерева. Всплывают почти все события. Например, событие focus не всплывает. То есть, при клике на элемент событие путешествует по цепочке родителей сначала вниз к элементу («погружается»), а потом наверх («всплывает»), по пути задействуя обработчики.
			</p>
		</div>
		<div class="pair events">
			<p class="question">62.Что такое объект Event? Какую информацию он хранит?</p>
			<p class="answer disabled">
				Чтобы хорошо обработать событие, недостаточно знать о том, что это – «клик» или «нажатие клавиши». Могут понадобиться детали: координаты курсора, введённый символ и другие, в зависимости от события. Детали произошедшего браузер записывает в «объект события», который передаётся первым аргументом event в обработчик для всех браузеров, кроме IE8-, в которых используется глобальная переменная window.event. Свойства объекта event: event.type - тип события; event.currentTarget - элемент, на котором сработал обработчик. Значение – в точности такое же, как и у this, но бывают ситуации, когда обработчик является методом объекта и его this при помощи bind привязан к этому объекту, тогда мы можем использовать event.currentTarget; event.clientX / event.clientY - координаты курсора в момент клика (относительно окна). Есть также и ряд других свойств, в зависимости от событий. При назначении обработчика в HTML, тоже можно использовать переменную event, это будет работать кросс-браузерно.
			</p>
		</div>
		<div class="pair events">
			<p class="question">63.Как отменить событие по умолчанию?</p>
			<p class="answer disabled">
				Многие события автоматически влекут за собой действие браузера. Например: клик по ссылке инициирует переход на новый URL. Если мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. Его можно отменить. Есть два способа отменить действие браузера: <br>
				Основной способ – это воспользоваться объектом события. Для отмены действия браузера существует стандартный метод event.preventDefault(). 
				Если же обработчик назначен через onсобытие (не через addEventListener), то можно просто вернуть false из обработчика. Возвращать true не нужно. Обычно значение, которое возвращает обработчик события, игнорируется. Единственное исключение – это return false из обработчика, назначенного через onсобытие.
		</div>
		<div class="pair events">
			<p class="question">64.Как остановить "всплытие" на каком-то элементе? Почему это нужно делать с осторожностью?</p>
			<p class="answer disabled">
				Всплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента &lt;html&gt;, а затем до document, а иногда даже до window, вызывая все обработчики на своем пути. Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие. Для остановки всплытия нужно вызвать метод event.stopPropagation().
				Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены. То есть, stopPropagation препятствует продвижению события дальше, но на текущем элементе все обработчики отработают. Для того, чтобы полностью остановить обработку, современные браузеры поддерживают метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе. <br>
				Не следует прекращать всплытие без явной нужды, очевидной и архитектурно прозрачной. Зачастую прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить. Проблема в том, что stopPropagation убивает всякую возможность отследить событие сверху, а это бывает нужно.
			</p>
		</div>
		<div class="pair server">
			<p class="question">65.Объясни принцип асинхронности.</p>
			<p class="answer disabled">
				Любое приложение — это набор последовательных инструкций. Чтобы выполнить следующую инструкцию, нужно дождаться окончания выполнения предыдущей. Время выполнения всей программы — это суммарное время выполнения всех инструкций. А это значит, что медленная часть программы будет делать медленной всю программу. Когда речь идет о генерации ответа пользователю от Web приложения, многие операции можно "откладывать". Имеет смысл откладывать тяжелые операции, которые могут отнять кучу времени (например, отправка внешних запросов и обработка ответов). Все эти операции могут быть выполнены позже, а пользователь получит быстрый ответ от системы и продолжит ее использование. <br>
				Асинхронный код - код, который выполняется параллельно с выполнением другого кода и не блокирует его. Асинхронные операции не могут генерировать ответ пользователю. Т.е. перенося операцию в асинхронное выполнение, нужно убрать из нее всю логику взаимодействия с пользователем. <br>
				Системы очередей позволяют внедрить асинхронную работу в любое приложение. Вместо выполнения тяжелого участка кода, нужно направить сообщение на сервер очереди. А сам тяжелый участок перенести в отдельный обработчик, который будет работать независимо от основного приложения. <br>
				Использовать преимущества асинхронной работы можно также и на клиентской стороне. В этом случае, следует разделить загрузку страницы на загрузку нескольких компонент, происходящую независимо друг от друга. Например, на странице используются данные от внешнего API. Чтобы скорость загрузки страницы не зависела от скорости работы API, можно создать отдельную страницу, которая будет содержать только логику получения данных от API. А основная страница будет загружать ее с помощью AJAX. <br>
				AJAX (Asynchronous Javascript And Xml) - подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в "фоновом" обмене данными браузера с веб-сервером. В результате, при обновлении данных веб-страница не перезагружается полностью, и веб-приложения становятся быстрее и удобнее.
			</p>
		</div>
		<div class="pair server">
			<p class="question">66.Что такое API?</p>
			<p class="answer disabled">
				API (Application Programming Interface) - это интерфейс программирования, интерфейс создания приложений. Если говорить более понятным языком, то API - это готовый код для упрощения жизни программисту. API создавался для того, чтобы программист реально мог облегчить задачу написания того или иного приложения благодаря использованию готового кода (например, функции).
			</p>
		</div>
		<div class="pair server">
			<p class="question">67.Зачем нужен XHR?</p>
			<p class="answer disabled">
				XMLHttpRequest (или, как его кратко называют, «XHR») дает возможность делать HTTP-запросы к серверу без перезагрузки страницы. Несмотря на слово «XML» в названии, XMLHttpRequest может работать с любыми данными, а не только с XML. Как правило, XMLHttpRequest используют для загрузки данных. <br>
				Методы XMLHttpRequest: <br>
				xhr.open(method, URL, async, user, password) - этот метод, как правило, вызывается первым после создания объекта XMLHttpRequest. Задаёт основные параметры запроса: method (HTTP-метод. Как правило, используется GET либо POST, хотя доступны и другие, вроде TRACE/DELETE/PUT и т.п.); URL (адрес запроса. Можно использовать не только http/https, но и другие протоколы, например ftp:// и file://. При этом есть ограничения безопасности, называемые «Same Origin Policy»: запрос со страницы можно отправлять только на тот же протокол://домен:порт, с которого она пришла.); async (если установлено в false, то запрос производится синхронно, если true – асинхронно); user, password (логин и пароль для HTTP-авторизации, если нужны). «Синхронный запрос» означает, что после вызова xhr.send() и до ответа сервера главный поток будет «заморожен»: посетитель не сможет взаимодействовать со страницей – прокручивать, нажимать на кнопки и т.п. После получения ответа выполнение продолжится со следующей строки. «Асинхронный запрос» означает, что браузер отправит запрос, а далее результат нужно будет получить через обработчики событий. Вызов open, в противоположность своему названию (open – англ. «открыть») не открывает соединение. Он лишь настраивает запрос, а коммуникация инициируется методом send. <br>
				xhr.send([body]) - этод метод открывает соединение и отправляет запрос на сервер. В body находится тело запроса. Не у всякого запроса есть тело, например у GET-запросов тела нет, а у POST – основные данные как раз передаются через body. <br>
				xhr.abort() - прерывает выполнение запроса. <br>
				Основные свойства, содержащие ответ сервера: <br>
				status - HTTP-код ответа: 200, 404, 403 и так далее. Может быть также равен 0, если сервер не ответил или при запросе на другой домен. <br>
				statusText - текстовое описание статуса от сервера: OK, Not Found, Forbidden и так далее. <br>
				responseText - текст ответа сервера. <br>
				responseXML - если сервер вернул XML, снабдив его правильным заголовком Content-type: text/xml, то браузер создаст из него XML-документ. По нему можно будет делать запросы xhr.responseXml.querySelector("...") и другие. Оно используется редко, так как обычно используют не XML, а JSON. То есть, сервер возвращает JSON в виде текста, который браузер превращает в объект вызовом JSON.parse(xhr.responseText).
			</p>
		</div>
		<div class="pair server">
			<p class="question">68.Что такое fetch?</p>
			<p class="answer disabled">
				Метод fetch – это XMLHttpRequest нового поколения. Он предоставляет улучшенный интерфейс для осуществления запросов к серверу: как по части возможностей и контроля над происходящим, так и по синтаксису, так как построен на промисах. Поддержка в браузерах пока не очень распространена, но есть полифилл и не один. <br>
				Синтаксис метода fetch: let promise = fetch(url[, options]). url – URL, на который сделать запрос; options – необязательный объект с настройками запроса. Свойства options: method – метод запроса; headers – заголовки запроса (объект); body – тело запроса: FormData, Blob, строка и т.п.; mode – одно из: «same-origin», «no-cors», «cors», указывает, в каком режиме кросс-доменности предполагается делать запрос; credentials – одно из: «omit», «same-origin», «include», указывает, пересылать ли куки и заголовки авторизации вместе с запросом; cache – одно из «default», «no-store», «reload», «no-cache», «force-cache», «only-if-cached», указывает, как кешировать запрос; redirect – можно поставить «follow» для обычного поведения при коде 30x (следовать редиректу) или «error» для интерпретации редиректа как ошибки. <br>
				Надо понимать, что если мы используем полифилл, то ничего более гибкого, чем оригинальный XMLHttpRequest мы из этого не получим. Разве что, fetch, возможно, будет удобнее пользоваться. <br>
				При вызове fetch возвращает промис, который, когда получен ответ, выполняет коллбэки с объектом Response или с ошибкой, если запрос не удался. Объект response кроме доступа к заголовкам headers, статусу status и некоторым другим полям ответа, даёт возможность прочитать его тело, в желаемом формате. Варианты описаны в спецификации Body, они включают в себя: response.arrayBuffer(); response.blob(); response.formData(); response.json(); response.text(). Соответствующий вызов возвращает промис, который, когда ответ будет получен, вызовет коллбэк с результатом.
			</p>
		</div>
		<div class="pair server">
			<p class="question">69.Какие есть встроенные события у XHR? Что значат фазы события onreadystatechange? Когда срабатывает onerror? Как установить HTTP-заголовок в XHR?</p>
			<p class="answer disabled">
				Современная спецификация предусматривает следующие события по ходу обработки запроса: loadstart (запрос начат), progress (браузер получил очередной пакет данных, можно прочитать текущие полученные данные в responseText), abort (запрос был отменён вызовом xhr.abort()), error (произошла ошибка), load (запрос был успешно (без ошибок) завершён), timeout (запрос был прекращён по таймауту), loadend (запрос был завершён (успешно или неуспешно)). Используя эти события можно более удобно отслеживать загрузку (onload) и ошибку (onerror), а также количество загруженных данных (onprogress). 
				Событие onerror срабатывает при возникновении ошибок сетевого уровня. Т.е. если запрос вообще не вернулся или отклонен согласно кроссдоменным ограничениям. Если запрос вообще вернулся, и даже с кодом ошибки, то onerror не сработает.<br>
				
				Событие readystatechange появилось гораздо раньше, ещё до появления текущего стандарта. В современных браузерах от него можно отказаться в пользу других, необходимо лишь учесть особенности IE8-9. Событие readystatechange происходит несколько раз в процессе отсылки и получения ответа. Свойство xhr.onreadystatechange содержит обработчик события, вызываемый когда происходит событие readystatechange, всякий раз  когда свойство readyState запроса XMLHttpRequest изменяется. Функция обратного вызова запускается из потока пользовательского интерфейса. 
				При этом можно посмотреть «текущее состояние запроса» в свойстве xhr.readyState. Все состояния, по спецификации: const unsigned short UNSENT = 0; - объект был создан, метод open() ещё не вызывался; const unsigned short OPENED = 1; - метод open() был вызван; const unsigned short HEADERS_RECEIVED = 2; - метод send() был вызван, доступны заголовки (headers) и статус; const unsigned short LOADING = 3; - загрузка, responseText содержит частичные данные; const unsigned short DONE = 4; - операция полностью завершена. Запрос проходит их в порядке 0 → 1 → 2 → 3 → … → 3 → 4, состояние 3 повторяется при каждом получении очередного пакета данных по сети. <br>
				При состоянии readyState=3 (получен очередной пакет) мы можем посмотреть текущие данные в responseText и, казалось бы, могли бы работать с этими данными как с «ответом на текущий момент». Однако, технически мы не управляем разрывами между сетевыми пакетами. Это опасно хотя бы тем, что символы русского языка в кодировке UTF-8 кодируются двумя байтами каждый – и разрыв может возникнуть между ними. Получится, что при очередном readyState в конце responseText будет байт-полсимвола, то есть он не будет корректной строкой – частью ответа! Если в скрипте как-то по-особому это не обработать, то неизбежны проблемы. <br>
				XHR умеет как указывать свои заголовки в запросе, так и читать присланные в ответ. Для работы с HTTP-заголовками есть 3 метода: <br>
				xhr.setRequestHeader(name, value) - устанавливает заголовок name запроса со значением value. Нельзя установить заголовки, которые контролирует браузер, например Referer или Host и ряд других. Это ограничение существует в целях безопасности и для контроля корректности запроса. Особенностью XMLHttpRequest является то, что отменить setRequestHeader невозможно. Повторные вызовы лишь добавляют информацию к заголовку. <br>
				xhr.getResponseHeader(name) - возвращает значение заголовка ответа name, кроме Set-Cookie и Set-Cookie2. <br>
				xhr.getAllResponseHeaders() - возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2. Заголовки возвращаются в виде единой строки. Между заголовками стоит перевод строки в два символа "\r\n" (не зависит от ОС), значение заголовка отделено двоеточием с пробелом ": ". Этот формат задан стандартом. Таким образом, если хочется получить объект с парами заголовок-значение, то эту строку необходимо разбить и обработать.
			</p>
		</div>
		<div class="pair server">
			<p class="question">70.Что такое CORS? Зачем нужен? Объясни принцип работы и сферу использования JSONP?</p>
			<p class="answer disabled">
				Cross-origin resource sharing (CORS; англ. - "совместное использование ресурсов между разными источниками") - технология современных браузеров, которая позволяет предоставить веб-странице доступ к ресурсам другого домена. Раньше для решения этой задачи использовали JSONP. <br>
				Кросс-доменные запросы делятся на два вида: <br>
				Простыми считаются запросы, если они удовлетворяют следующим двум условиям: <br>
				1.Простой метод: GET, POST или HEAD; <br>
				2.Простые заголовки – только из списка: Accept, Accept-Language, Content-Language, Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или text/plain. <br>
				«Непростыми» считаются все остальные, например, запрос с методом PUT или с заголовком Authorization не подходит под ограничения выше. <br>
				Принципиальная разница между ними заключается в том, что «простой» запрос можно сформировать и отправить на сервер и без XMLHttpRequest, например при помощи HTML-формы. <br>
				В спецификации CORS есть много деталей, но все они объединены единым принципом: новые возможности доступны только с явного согласия сервера (по умолчанию – нет). <br>
				В кросс-доменный запрос браузер автоматически добавляет заголовок Origin, содержащий домен, с которого осуществлён запрос. Сервер должен, со своей стороны, ответить специальными заголовками, разрешает ли он такой запрос к себе. Если сервер разрешает кросс-доменный запрос с этого домена – он должен добавить к ответу заголовок Access-Control-Allow-Origin, содержащий домен запроса или звёздочку *. Только при наличии такого заголовка в ответе – браузер сочтёт запрос успешным, а иначе JavaScript получит ошибку. При таких запросах не передаются куки и заголовки HTTP-авторизации. Параметры user и password в методе open игнорируются. Описанные выше ограничения приводят к тому, что запрос полностью безопасен. Действительно, злая страница может сформировать любой GET/POST-запрос и отправить его, но без разрешения сервера ответа она не получит. А без ответа такой запрос, по сути, эквивалентен отправке формы GET/POST, причём без авторизации. <br>
				Чтобы JavaScript мог прочитать HTTP-заголовок ответа, сервер должен указать его имя в Access-Control-Expose-Headers. По умолчанию скрипт может прочитать из ответа только «простые» заголовки: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma. То есть, Content-Type получить всегда можно, а доступ к специфическим заголовкам нужно открывать явно. <br>
				Чтобы браузер передал вместе с запросом куки и HTTP-авторизацию, нужно поставить запросу xhr.withCredentials = true. Далее – всё как обычно, дополнительных действий со стороны клиента не требуется. Такой XMLHttpRequest с куками, естественно, требует от сервера больше разрешений, чем «анонимный». Поэтому для запросов с withCredentials предусмотрено дополнительное подтверждение со стороны сервера. При запросе с withCredentials сервер должен вернуть уже не один, а два заголовка: <br>
				Access-Control-Allow-Origin: домен; <br>
				Access-Control-Allow-Credentials: true. <br>
				Использование звёздочки * в Access-Control-Allow-Origin при этом запрещено. Если этих заголовков не будет, то браузер не даст JavaScript’у доступ к ответу сервера. <br>
				Для запросов с «непростым» методом или особыми заголовками браузер делает предзапрос OPTIONS, указывая их в Access-Control-Request-Method и Access-Control-Request-Headers. Браузер ожидает ответ со статусом 200, без тела, со списком разрешённых методов и заголовков в Access-Control-Allow-Method и Access-Control-Allow-Headers. Дополнительно можно указать Access-Control-Max-Age (количество секунд) для кеширования предзапроса. Тогда при последующих вызовах метода браузер уже не будет делать предзапрос. <br>

				Если создать тег &lt;script src&gt;, то при добавлении в документ запустится процесс загрузки src. В ответ сервер может прислать скрипт, содержащий нужные данные. Таким образом можно запрашивать данные с любого сервера, в любом браузере, без каких-либо разрешений и дополнительных проверок. Протокол JSONP – это «надстройка» над таким способом коммуникации. Когда нужно одновременно делать несколько запросов, протокол JSONP призван облегчить эту задачу. Он очень простой: <br>
				1.Вместе с запросом клиент в специальном, заранее оговорённом, параметре передаёт название функции. Обычно такой параметр называется callback. <br>
				2.Сервер кодирует данные в JSON и оборачивает их в вызов функции, название которой получает из параметра callback. <br>
				Это и называется JSONP («JSON with Padding»). Клиентский код должен доверять серверу при таком запросе. Ведь серверу ничего не стоит добавить в скрипт любые команды. Функция должна быть глобальной, ведь &lt;script src&gt; выполняется в глобальной области видимости. Хотелось бы не загрязнять глобальное пространство имён, или по крайней мере свести загрязнение к минимуму. Как правило, для этого создают один глобальный объект «реестр», например, CallbackRegistry. Далее для каждого запроса в нём генерируется временная функция. Пример: &lt;script src="user?id=123&callback=CallbackRegistry.func12345"&gt;&lt;/script&gt; 
				Сервер обернёт ответ в функцию CallbackRegistry.func12345, она вызывает нужный обработчик и очищает память, удаляя себя. <br>
				При запросе данных при помощи SCRIPT возможны различные ошибки: скрипт может не загрузиться: отказ в соединении, разрыв связи…; ошибка HTTP, например 500; скрипт загрузился, но внутри некорректен и не вызывает функцию. Например, на сервере произошла ошибка и в ответе передан её текст, а вовсе не данные. <br>
				Чтобы отловить их все «одним махом», используется следующий алгоритм: <br>
				1.Создаётся &lt;script&gt;. <br>
				2.На &lt;script&gt; ставятся обработчики onreadystatechange (для старых IE) и onload/onerror (для остальных браузеров). <br>
				3.При загрузке скрипт выполняет функцию-коллбэк CallbackRegistry.... Пусть она при запуске ставит флажок «все ок». А мы в обработчиках проверим – если флага нет, то функция не вызывалась – стало быть, ошибка при загрузке или содержимое скрипта некорректно.				
			</p>
		</div>
		<div class="pair server">
			<p class="question">71.Как в JS можно работать с JSON? А с XML? Опиши встроенные методы.</p>
			<p class="answer disabled">
				JSON (JavaScript Object Notation) - текстовый формат обмена данными, основаный на JavaScript. Как и многие другие текстовые форматы, JSON легко читается людьми. Несмотря на происхождение от JavaScript, формат считается независимым от языка и может использоваться практически с любым языком программирования. Для многих языков существует готовый код для создания и обработки данных в формате JSON. 
				Данные в формате JSON представляют собой: JavaScript-объекты или массивы, или значения одного из типов (строки в двойных кавычках, число, логическое значение true/false, null).
				Объекты в формате JSON похожи на обычные JavaScript-объекты, но отличаются от них более строгими требованиями к строкам – они должны быть именно в двойных кавычках. Кроме того, в формате JSON не поддерживаются комментарии. Он предназначен только для передачи данных. Есть нестандартное расширение формата JSON, которое называется JSON5 и как раз разрешает ключи без кавычек, комментарии и т.п., как в обычном JavaScript. <br>
				Основные методы для работы с JSON в JavaScript – это: <br>
				JSON.parse – превратит строку с данными в формате JSON в JavaScript-объект/массив/значение. Для интеллектуального восстановления из строки у JSON.parse(str, reviver) есть второй параметр reviver, который является функцией function(key, value). Если она указана, то в процессе чтения объекта из строки JSON.parse передаёт ей по очереди все создаваемые пары ключ-значение и может возвратить либо преобразованное значение, либо undefined, если его нужно пропустить. <br>
				JSON.stringify(value, replacer, space) – преобразует ("сериализует") значение в строку в формате JSON, используется, когда нужно из JavaScript передать данные по сети. При сериализации объекта вызывается его метод toJSON. Если такого метода нет – перечисляются его свойства, кроме функций. У всех дат есть встроенный метод toJSON. Во втором параметре JSON.stringify(value, replacer) можно указать массив свойств, которые подлежат сериализации. Функция replacer работает рекурсивно. Если третий параметр space является числом – то уровни вложенности в JSON оформляются указанным количеством пробелов, если строкой – вставляется эта строка.<br>
				XML (Extensible Markup Language) - расширяемый язык разметки, достаточно похожий на HTML, но с более строгим синтаксисом. В XML поле объекта можно представить в виде отдельного тега, у которого могут быть дополнительные атрибуты. При этом, имена этих тегов и атрибутов придумывает сам разработчик, т.е., тут нет фиксированной грамматики. Для XML документа создается DOM-дерево и по нему можно двигаться, как по обычному HTML. <br>
				DOMParser - может парсить XML, HTML, SVG источник, содержащийся в строке в DOM Document, в объект. XMLHttpRequest поддерживает парсинг XML и HTML из интернет ресурсов (по ссылке). Для того чтобы создать DOMParser используется new DOMParser(). Если процесс парсинга не удастся , DOMParser теперь не выдает исключение, но вместо этого выдает документ ошибки. Ошибки синтаксического анализа также сообщаются в консоль ошибок, с идентификатором URI документа в качестве источника ошибки. <br>
				parseFromString(stringContainingXMLSource, 'application/xml') - как только создан объект парсера, можно парсить XML из строки, используя этот метод. Результатом работы данного метода является объект DOM, а если точнее – это либо объект HTMLDocument (в случае HTML), либо объект Document (в случае XML), либо SVGDocument (в случае SVG).
			</p>
		</div>
		<div class="pair server">
			<p class="question">72.Опиши, как работают промисы. Можно ли использовать XHR вместе с промисами?</p>
			<p class="answer disabled">
				Promise (промисы) – это специальный объект, который хранит своё состояние, текущий результат (если есть) и коллбэки. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»). Promise предоставляют удобный способ организации асинхронного кода. В современном JavaScript промисы часто используются в том числе и неявно, при помощи генераторов. <br>
				На promise можно навешивать коллбэки двух типов: onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно»; onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой». <br>
				Способ использования: <br>
				1.Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его. <br>
				2.Внешний код, получив promise, навешивает на него обработчики. <br>
				3.По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде. <br>
				Синтаксис создания Promise: const promise = new Promise(function(resolve, reject) {...}). Эта функция будет вызвана автоматически. В ней можно делать любые асинхронные операции, а когда они завершатся — нужно вызвать одно из: resolve(результат) при успешном выполнении, reject(ошибка) при ошибке. <br>
				Универсальный метод для навешивания обработчиков: promise.then(onFulfilled, onRejected). С его помощью можно назначить как оба обработчика сразу, так и только один: promise.then(onFulfilled); promise.then(null, onRejected). Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое. <br>
				Если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject. Функции resolve/reject принимают ровно один аргумент – результат/ошибку. Именно он передаётся обработчикам в .then. <br>
				Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда. <br>
				Промисификация – это когда берут асинхронный функционал и делают для него обёртку, возвращающую промис. После промисификации использование функционала зачастую становится гораздо удобнее. Примером может быть такая обёртка для запросов при помощи XHR. Функция httpGet(url) будет возвращать промис, который при успешной загрузке данных с url будет переходить в fulfilled с этими данными, а при ошибке – в rejected с информацией об ошибке. Внутри функции объект XMLHttpRequest создаётся и отсылается как обычно, при onload/onerror вызываются, соответственно, resolve (при статусе 200) или reject. <br>

				«Чейнинг» (chaining), то есть возможность строить асинхронные цепочки из промисов – пожалуй, основная причина, из-за которой существуют и активно используются промисы. При чейнинге, то есть последовательных вызовах .then…then…then, в каждый следующий then переходит результат от предыдущего. Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат. Если then возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать. Общее правило: если внутри then стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис. <br>
				При возникновении ошибки – она отправляется в ближайший обработчик onRejected. Такой обработчик нужно поставить через второй аргумент .then(..., onRejected) или, что то же самое, через .catch(onRejected). Принцип очень похож на обычный try..catch: мы делаем асинхронную цепочку из .then, а затем, в том месте кода, где нужно перехватить ошибки, вызываем .catch(onRejected). Обработчик .catch(onRejected) получает ошибку и должен обработать её. Это также похоже на обычный try..catch – в блоке catch ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает throw. Существенное отличие – в том, что промисы асинхронные, поэтому при отсутствии внешнего .catch ошибка не «вываливается» в консоль и не «убивает» скрипт. <br>

				Для осуществления нескольких асинхронных процессов одновременно и обработки их результатов в классе Promise есть следующие статические методы: <br>
				Promise.all(iterable) - вызов этого метода получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов. Если какой-то из промисов завершился с ошибкой, то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются. <br>
				Promise.race - вызов этого метода, как и Promise.all, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис. Но, в отличие от Promise.all, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются. <br>
				Promise.resolve(value) - создаёт успешно выполнившийся промис с результатом value. Его используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть. <br>
				Promise.reject(error) - аналогично создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой error. Используется очень редко, гораздо реже чем resolve, потому что ошибка возникает обычно не в начале цепочки, а в процессе её выполнения.
			</p>
		</div>
		<div class="pair server">
			<p class="question">73.Зачем используется конструкция try...catch...finally?</p>
			<p class="answer disabled">
				Конструкция try..catch..finally – позволяет обработать произвольные ошибки в блоке кода.
				Обычно скрипт при ошибке, как говорят, «падает», с выводом ошибки в консоль. Но бывают случаи, когда нужно как-то контролировать ситуацию, чтобы скрипт не просто «упал», а сделал что-то разумное. Для этого в JavaScript есть конструкция try..catch. Конструкция try..catch состоит из двух основных блоков: try, и затем catch(err). Работает она так: <br>
				1.Выполняется код внутри блока try. <br>
				2.Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение доходит до конца try и потом прыгает через catch. <br>
				3.Если в нём возникнет ошибка, то выполнение try на ней прерывается, и управление прыгает в начало блока catch(err). При этом переменная err (можно выбрать и другое название) будет содержать объект ошибки с подробной информацией о произошедшем. Таким образом, при ошибке в try скрипт не «падает», и мы получаем возможность обработать ошибку внутри catch. <br>
				Если грубо нарушена структура кода, например не закрыта фигурная скобка или где-то стоит лишняя запятая, то никакой try..catch здесь не поможет. Такие ошибки называются синтаксическими, интерпретатор не может понять такой код. Эта конструкция воспринимает ошибки семантические, то есть происходящие в корректном коде, в процессе выполнения. <br>
				try..catch работает только в синхронном коде. На момент запуска функции, назначенной, например, через setTimeout, этот код уже завершится, интерпретатор выйдет из блока try..catch. Чтобы поймать ошибку внутри функции из setTimeout, и try..catch должен быть в той же функции. <br>
				У объекта ошибки есть три основных свойства: name (тип ошибки. Например, при обращении к несуществующей переменной: "ReferenceError"); message (текстовое сообщение о деталях ошибки); stack (есть везде, кроме IE8-, содержит строку с информацией о последовательности вызовов, которая привела к ошибке); в зависимости от браузера у него могут быть и дополнительные свойства. <br>
				Оператор throw генерирует ошибку. Синтаксис: throw <объект ошибки>. Технически в качестве объекта ошибки можно передать что угодно, это может быть даже не объект, а число или строка, но всё же лучше, чтобы это был объект, желательно – совместимый со стандартным, то есть чтобы у него были как минимум свойства name и message. В качестве конструктора ошибок можно использовать встроенный конструктор: new Error(message) или любой другой. В качестве конструктора ошибок можно использовать встроенный конструктор: new Error(message) или любой другой. <br>
				Ошибку, о которой catch не знает, он не должен обрабатывать. Техника «проброс исключения»: в catch(e) мы анализируем объект ошибки, и если он нам не подходит, то делаем throw e. При этом ошибка «выпадает» из try..catch наружу. Далее она может быть поймана либо внешним блоком try..catch (если есть), либо «повалит» скрипт. <br>
				Конструкция try..catch может содержать ещё один блок: finally. Секция finally не обязательна, но если она есть, то она выполняется всегда: после блока try, если ошибок не было; после catch, если они были. Секцию finally используют, чтобы завершить начатые операции при любом варианте развития событий. Блок finally срабатывает при любом выходе из try..catch, в том числе и return.
			</p>
		</div>
	</div>
	<script src="js/common.min.js"></script>
</body>
</html>